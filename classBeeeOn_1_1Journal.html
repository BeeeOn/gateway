<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BeeeOn Gateway: BeeeOn::Journal Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Gateway
   &#160;<span id="projectnumber">v2018.07.1-rc3-77-g4b98a60</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BeeeOn</b></li><li class="navelem"><a class="el" href="classBeeeOn_1_1Journal.html">Journal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BeeeOn::Journal Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classBeeeOn_1_1Journal.html" title="Journal implements a simple journaling principle in filesystem. A Journal instance represents an appe...">Journal</a> implements a simple journaling principle in filesystem. A <a class="el" href="classBeeeOn_1_1Journal.html" title="Journal implements a simple journaling principle in filesystem. A Journal instance represents an appe...">Journal</a> instance represents an append-only persistent list of records. Appending is an atomic operation. We either append the whole record or append nothing.  
 <a href="classBeeeOn_1_1Journal.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Journal_8h_source.html">Journal.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BeeeOn::Journal:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBeeeOn_1_1Journal.png" usemap="#BeeeOn::Journal_map" alt=""/>
  <map id="BeeeOn::Journal_map" name="BeeeOn::Journal_map">
<area href="classBeeeOn_1_1Loggable.html" alt="BeeeOn::Loggable" shape="rect" coords="0,0,116,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single record in journal.  <a href="structBeeeOn_1_1Journal_1_1Record.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a45ab489a15ca7866e1df24eda7144fca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45ab489a15ca7866e1df24eda7144fca"></a>
typedef Poco::SharedPtr&lt; <a class="el" href="classBeeeOn_1_1Journal.html">Journal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:a45ab489a15ca7866e1df24eda7144fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2c5109af8806e8e8f700858170d8741"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2c5109af8806e8e8f700858170d8741"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Journal</b> (const Poco::Path &amp;file, double duplicatesFactor=3, size_t minimalRewritesSize=4096)</td></tr>
<tr class="separator:ad2c5109af8806e8e8f700858170d8741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712b184de524afcd046f5f0f8570bb04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a712b184de524afcd046f5f0f8570bb04">createEmpty</a> ()</td></tr>
<tr class="memdesc:a712b184de524afcd046f5f0f8570bb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty journal if it does not exists yet.  <a href="#a712b184de524afcd046f5f0f8570bb04">More...</a><br/></td></tr>
<tr class="separator:a712b184de524afcd046f5f0f8570bb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45603bb73f5f33cc511d2aaf8cd39260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a45603bb73f5f33cc511d2aaf8cd39260">checkExisting</a> (bool regularFile=true, bool writable=true) const </td></tr>
<tr class="memdesc:a45603bb73f5f33cc511d2aaf8cd39260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for common situations that might be a symptom of an invalid setup. We check whether the underlying file is readable, (optionally) writable and (optionally) whether it is a regular file. If the file does not exists, we test the parent directory whether it is readable and (optionally) wriable.  <a href="#a45603bb73f5f33cc511d2aaf8cd39260">More...</a><br/></td></tr>
<tr class="separator:a45603bb73f5f33cc511d2aaf8cd39260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be91fad9960bce3092b00fc24b7489"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85be91fad9960bce3092b00fc24b7489"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a85be91fad9960bce3092b00fc24b7489">load</a> (bool recover=false)</td></tr>
<tr class="memdesc:a85be91fad9960bce3092b00fc24b7489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the journal from the underlying file. If the parameter recover is true, the method skips malformed entries (with invalid checkums). Otherwise, the method throws an exception. <br/></td></tr>
<tr class="separator:a85be91fad9960bce3092b00fc24b7489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5acecd8c211925ffca7dc26900345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#aa0e5acecd8c211925ffca7dc26900345">load</a> (std::istream &amp;in, bool recover=false)</td></tr>
<tr class="memdesc:aa0e5acecd8c211925ffca7dc26900345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the journal from the given stream. If the parameter recover is true, the method skips malformed entries (with invalid checkums). Otherwise, the method throws an exception.  <a href="#aa0e5acecd8c211925ffca7dc26900345">More...</a><br/></td></tr>
<tr class="separator:aa0e5acecd8c211925ffca7dc26900345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43cd386f51cbf14ae3aa46433191c36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac43cd386f51cbf14ae3aa46433191c36"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#ac43cd386f51cbf14ae3aa46433191c36">checkConsistent</a> () const </td></tr>
<tr class="memdesc:ac43cd386f51cbf14ae3aa46433191c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the RAM journal representation is equivalent to the persistent representation in the underlying file. <br/></td></tr>
<tr class="separator:ac43cd386f51cbf14ae3aa46433191c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d04064bf8b66c84665203bf7d917c29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d04064bf8b66c84665203bf7d917c29"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a9d04064bf8b66c84665203bf7d917c29">checkConsistent</a> (std::istream &amp;in) const </td></tr>
<tr class="memdesc:a9d04064bf8b66c84665203bf7d917c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the RAM journal representation is equivalent to the representation readed from the given input stream. <br/></td></tr>
<tr class="separator:a9d04064bf8b66c84665203bf7d917c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b807e80a707fffa2cbdaea2990b737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a84b807e80a707fffa2cbdaea2990b737">append</a> (const std::string &amp;key, const std::string &amp;value, bool <a class="el" href="classBeeeOn_1_1Journal.html#a6249e5cdb8dd03da19f75712fe6780a0">flush</a>=true)</td></tr>
<tr class="memdesc:a84b807e80a707fffa2cbdaea2990b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the key-value pair into the journal.  <a href="#a84b807e80a707fffa2cbdaea2990b737">More...</a><br/></td></tr>
<tr class="separator:a84b807e80a707fffa2cbdaea2990b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271a18a04bb584d961e92dbacf33c2ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a271a18a04bb584d961e92dbacf33c2ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a271a18a04bb584d961e92dbacf33c2ec">append</a> (const <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &amp;record, bool <a class="el" href="classBeeeOn_1_1Journal.html#a6249e5cdb8dd03da19f75712fe6780a0">flush</a>=true)</td></tr>
<tr class="memdesc:a271a18a04bb584d961e92dbacf33c2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the given record into the journal. If the parameter flush is true (default), the record is immediatelly persisted and flushed. Otherwise, it is written into a waiting list to be flush in a batch. <br/></td></tr>
<tr class="separator:a271a18a04bb584d961e92dbacf33c2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feb4a2be3af30f76e5d429eefe16b5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a8feb4a2be3af30f76e5d429eefe16b5d">drop</a> (const std::string &amp;key, bool <a class="el" href="classBeeeOn_1_1Journal.html#a6249e5cdb8dd03da19f75712fe6780a0">flush</a>=true)</td></tr>
<tr class="memdesc:a8feb4a2be3af30f76e5d429eefe16b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given key as dropped.  <a href="#a8feb4a2be3af30f76e5d429eefe16b5d">More...</a><br/></td></tr>
<tr class="separator:a8feb4a2be3af30f76e5d429eefe16b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3fb1a155c454423a028b056106d183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b3fb1a155c454423a028b056106d183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a6b3fb1a155c454423a028b056106d183">drop</a> (const std::set&lt; std::string &gt; &amp;keys, bool <a class="el" href="classBeeeOn_1_1Journal.html#a6249e5cdb8dd03da19f75712fe6780a0">flush</a>=true)</td></tr>
<tr class="memdesc:a6b3fb1a155c454423a028b056106d183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all the given keys as dropped. The operation itself can be delayed when the parameter flush is false. Otherwise, all the keys are immediatelly persisted and flushed. Note that dropping multiple keys is NOT an atomic operation. We can end up with only few keys dropped in case of a serious failure. <br/></td></tr>
<tr class="separator:a6b3fb1a155c454423a028b056106d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6249e5cdb8dd03da19f75712fe6780a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6249e5cdb8dd03da19f75712fe6780a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a6249e5cdb8dd03da19f75712fe6780a0">flush</a> ()</td></tr>
<tr class="memdesc:a6249e5cdb8dd03da19f75712fe6780a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all records in the waiting list. If the current duplicates factor is high enough and the size of the journal is bigger than the minimal rewrite size, the deduplication is performed. In case of an I/O failure while deduplicating, it fallbacks to simple append with flush. <br/></td></tr>
<tr class="separator:a6249e5cdb8dd03da19f75712fe6780a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa600e168f99eb7cac49dfdc2afe30a1f"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a> () const </td></tr>
<tr class="separator:aa600e168f99eb7cac49dfdc2afe30a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9da130365a65eb34a9b00eb568e50cf"><td class="memItemLeft" align="right" valign="top">Poco::Nullable&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#aa9da130365a65eb34a9b00eb568e50cf">operator[]</a> (const std::string &amp;key) const </td></tr>
<tr class="separator:aa9da130365a65eb34a9b00eb568e50cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adaa355bb21d3ec2edd4d8cdda2dee8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1Journal.html#a3adaa355bb21d3ec2edd4d8cdda2dee8">currentDuplicatesFactor</a> () const </td></tr>
<tr class="separator:a3adaa355bb21d3ec2edd4d8cdda2dee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adb950c8018c3bf560f1267139ca2bc0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb950c8018c3bf560f1267139ca2bc0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseStream</b> (std::istream &amp;in, std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>) const </td></tr>
<tr class="separator:adb950c8018c3bf560f1267139ca2bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98115283adc1059b6c436fc0e4b0059c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98115283adc1059b6c436fc0e4b0059c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseStreamRecover</b> (std::istream &amp;in, std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>) const </td></tr>
<tr class="separator:a98115283adc1059b6c436fc0e4b0059c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bc99e15aecdb1342efdc6c9cb1a868"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12bc99e15aecdb1342efdc6c9cb1a868"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendDrop</b> (const std::string &amp;key, bool <a class="el" href="classBeeeOn_1_1Journal.html#a6249e5cdb8dd03da19f75712fe6780a0">flush</a>)</td></tr>
<tr class="separator:a12bc99e15aecdb1342efdc6c9cb1a868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0577a2f2f2d801736f0f7c4c4926dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a0577a2f2f2d801736f0f7c4c4926dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dropInPlace</b> (std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>, const std::string &amp;key) const </td></tr>
<tr class="separator:a6a0577a2f2f2d801736f0f7c4c4926dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57db6cc66699e96702a30b9c6fa9cf75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57db6cc66699e96702a30b9c6fa9cf75"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>duplicatesFactor</b> (const std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>) const </td></tr>
<tr class="separator:a57db6cc66699e96702a30b9c6fa9cf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1caf275699db3e37f69d9b93dde460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1caf275699db3e37f69d9b93dde460"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>overMinimalSize</b> () const </td></tr>
<tr class="separator:a0f1caf275699db3e37f69d9b93dde460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae153a61caaa188c3f44df3a3fa287e94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae153a61caaa188c3f44df3a3fa287e94"></a>
std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>recordsRaw</b> () const </td></tr>
<tr class="separator:ae153a61caaa188c3f44df3a3fa287e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e561dcf00636a47167ec770cc873d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e561dcf00636a47167ec770cc873d0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>interpret</b> (std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>) const </td></tr>
<tr class="separator:a5e561dcf00636a47167ec770cc873d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a578f0338096b28a873645066eecb5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a578f0338096b28a873645066eecb5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>interpretAndFlush</b> ()</td></tr>
<tr class="separator:a4a578f0338096b28a873645066eecb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba1e9b5ac699853fefb5bf6c2d211ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ba1e9b5ac699853fefb5bf6c2d211ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendFlush</b> ()</td></tr>
<tr class="separator:a9ba1e9b5ac699853fefb5bf6c2d211ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09bb6fd34b2b2fbde6d169053a2c52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf09bb6fd34b2b2fbde6d169053a2c52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rewriteAndFlush</b> (const std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>)</td></tr>
<tr class="separator:acf09bb6fd34b2b2fbde6d169053a2c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349ff564a9ef3fd4ff788066ce657245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a349ff564a9ef3fd4ff788066ce657245"></a>
std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>committed</b> ()</td></tr>
<tr class="separator:a349ff564a9ef3fd4ff788066ce657245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef2440726b4cc0e9a61003863757c91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ef2440726b4cc0e9a61003863757c91"></a>
std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>dirty</b> ()</td></tr>
<tr class="separator:a3ef2440726b4cc0e9a61003863757c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdd3d0e96c65c9811a3c5e8d6a796af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fdd3d0e96c65c9811a3c5e8d6a796af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handleFailure</b> (std::ostream &amp;o) const </td></tr>
<tr class="separator:a9fdd3d0e96c65c9811a3c5e8d6a796af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363119d4da1eb2e75903c78cb57ba7a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a363119d4da1eb2e75903c78cb57ba7a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkRecord</b> (const <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &amp;record) const </td></tr>
<tr class="separator:a363119d4da1eb2e75903c78cb57ba7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b3536324bd274f5793ff87d9113d62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b3536324bd274f5793ff87d9113d62"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>format</b> (const <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &amp;record, bool zeroSum=false) const </td></tr>
<tr class="separator:a77b3536324bd274f5793ff87d9113d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa2978eb35474158659c505a5d635c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1aa2978eb35474158659c505a5d635c"></a>
<a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (const std::string &amp;line, size_t lineno) const </td></tr>
<tr class="separator:aa1aa2978eb35474158659c505a5d635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50485ccb6b14fc3630a395c1abc6fefb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50485ccb6b14fc3630a395c1abc6fefb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b> (const std::list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Record</a> &gt; &amp;<a class="el" href="classBeeeOn_1_1Journal.html#aa600e168f99eb7cac49dfdc2afe30a1f">records</a>) const </td></tr>
<tr class="separator:a50485ccb6b14fc3630a395c1abc6fefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89c60789e75cb07103e46d40a3ebb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setupLogger</b> (Poco::Logger *logger=0) const </td></tr>
<tr class="separator:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f8405547e70200fe594a24906d7e7e"></a>
Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>logger</b> () const </td></tr>
<tr class="separator:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28780034cab771631dfb4db98a7954bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba38a43bcc45e65dfb6455ad8ad2e1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93889eade4537aea6abb3f383a8463e"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forMethod</b> (const char *name)</td></tr>
<tr class="separator:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a559c00fe671201e7ee5cebf19706491d"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99f58cf545bb5550c42fbb75d4645c4a"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ddc275e696705f0e68a5332d2cd5960"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplItemLeft" align="right" valign="top">static Poco::Logger &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forInstance</b> (const T *i)</td></tr>
<tr class="separator:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c03d407c8269d8fc9f71f0161ae17ae"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>configureSimple</b> (Poco::Logger &amp;logger, const std::string &amp;level)</td></tr>
<tr class="separator:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classBeeeOn_1_1Journal.html" title="Journal implements a simple journaling principle in filesystem. A Journal instance represents an appe...">Journal</a> implements a simple journaling principle in filesystem. A <a class="el" href="classBeeeOn_1_1Journal.html" title="Journal implements a simple journaling principle in filesystem. A Journal instance represents an appe...">Journal</a> instance represents an append-only persistent list of records. Appending is an atomic operation. We either append the whole record or append nothing. </p>
<p>It is considered that the number of records is quite low (up to few kB). Each record consists of a key and value. The key is an identifier of some entity being changed. The value represents the change of its entity to be recorded. Appending a new value for an existing key means that the associated entity has been updated.</p>
<p>A journal is a sequential structure which gives it several properties:</p>
<ul>
<li>efficient writes to a persistent storage (reduced seeking and erasing)</li>
<li>appending data cannot destroy the previous contents</li>
<li>reading from begining leads to a stable interpretation of its records</li>
</ul>
<p><a class="el" href="classBeeeOn_1_1Journal.html" title="Journal implements a simple journaling principle in filesystem. A Journal instance represents an appe...">Journal</a> provides a way how to recover after a system or power failure. Based on the journal contents, it is possible to reconstruct the most recent consistent state.</p>
<p>Each persisted record is protected by the CRC32 checksum to detect incomplete writes or broken underlying storage. Records with invalid checksum can be in some scenarios just skipped (leads to a data loss) in other scenarios we might need to recover in a more complex ways which are currently unsupported by the <a class="el" href="classBeeeOn_1_1Journal.html" title="Journal implements a simple journaling principle in filesystem. A Journal instance represents an appe...">Journal</a> class.</p>
<p>To avoid infinite grow of the journal, it can be internally deduplicated and thus rotated. After some time, several entities in the journal would be contained multiple times with different values. However, only the most recent value is valid for each entity. Those duplications can be avoid once upon a time or when consuming too much of storage.</p>
<p>There are two parameters that triggers rotations:</p>
<ul>
<li>duplicates factor - average amount of key duplicates</li>
<li>minimal rewrite size - minimal size of the journal in bytes</li>
</ul>
<p>If there more duplicates than the valud of duplicates factor and the journal is currently bigger then the minimal rewrite size, the journal automatically deduplicates itself (during the flush operation) and writes its shrinked version safely into the storage. The rewrite utilizes the <a class="el" href="classBeeeOn_1_1SafeWriter.html" title="SafeWriter is a helper that allows to perform file writes that are atomic. SafeWriter always rewrites...">SafeWriter</a> to stay as safe as possible and prevent any or most data loss possibilities. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a84b807e80a707fffa2cbdaea2990b737"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BeeeOn::Journal::append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the key-value pair into the journal. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classBeeeOn_1_1Journal.html#a271a18a04bb584d961e92dbacf33c2ec" title="Append the given record into the journal. If the parameter flush is true (default), the record is immediatelly persisted and flushed. Otherwise, it is written into a waiting list to be flush in a batch. ">Journal::append(const Record &amp;, bool)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a45603bb73f5f33cc511d2aaf8cd39260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Journal::checkExisting </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>regularFile</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for common situations that might be a symptom of an invalid setup. We check whether the underlying file is readable, (optionally) writable and (optionally) whether it is a regular file. If the file does not exists, we test the parent directory whether it is readable and (optionally) wriable. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Poco::FileAccessDeniedException</td><td>- file is not readable </td></tr>
    <tr><td class="paramname">Poco::FileReadOnlyException</td><td>- file is not writable </td></tr>
    <tr><td class="paramname">Poco::InvalidArgumentException</td><td>- file is not a regular file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a712b184de524afcd046f5f0f8570bb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Journal::createEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create empty journal if it does not exists yet. </p>
<dl class="section return"><dt>Returns</dt><dd>true if created, false if it already exists </dd></dl>

</div>
</div>
<a class="anchor" id="a3adaa355bb21d3ec2edd4d8cdda2dee8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Journal::currentDuplicatesFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the current duplicates factor of the journal main records (waiting records are not counted). </p>

</div>
</div>
<a class="anchor" id="a8feb4a2be3af30f76e5d429eefe16b5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BeeeOn::Journal::drop </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the given key as dropped. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classBeeeOn_1_1Journal.html#a6b3fb1a155c454423a028b056106d183" title="Mark all the given keys as dropped. The operation itself can be delayed when the parameter flush is f...">Journal::drop(const std::set&lt;std::string&gt; &amp;, bool)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e5acecd8c211925ffca7dc26900345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Journal::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recover</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the journal from the given stream. If the parameter recover is true, the method skips malformed entries (with invalid checkums). Otherwise, the method throws an exception. </p>
<p>CAUTION: This operation may lead to have an inconsistent journal state between RAM and the underlying file when loading from another (underlated) data source. </p>

</div>
</div>
<a class="anchor" id="aa9da130365a65eb34a9b00eb568e50cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nullable&lt; string &gt; Journal::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>value of record by the given key or null is it is not in the journal </dd></dl>

</div>
</div>
<a class="anchor" id="aa600e168f99eb7cac49dfdc2afe30a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; <a class="el" href="structBeeeOn_1_1Journal_1_1Record.html">Journal::Record</a> &gt; Journal::records </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current state of each record, only the most recent records per key are returned this way (thus we have no access to the history by this method). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/util/<a class="el" href="Journal_8h_source.html">Journal.h</a></li>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/util/Journal.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
