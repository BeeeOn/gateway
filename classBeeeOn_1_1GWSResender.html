<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BeeeOn Gateway: BeeeOn::GWSResender Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Gateway
   &#160;<span id="projectnumber">v2018.12.1-rc1-52-g502c051</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BeeeOn</b></li><li class="navelem"><a class="el" href="classBeeeOn_1_1GWSResender.html">GWSResender</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BeeeOn::GWSResender Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sending of messages via a <a class="el" href="classBeeeOn_1_1GWSConnector.html" title="GWSConnector is an abstract class that defines an API for communication with a remote server...">GWSConnector</a> might not be reliable. Messages that have been sent can never reach the remote server. The <a class="el" href="classBeeeOn_1_1GWSResender.html" title="Sending of messages via a GWSConnector might not be reliable. Messages that have been sent can never ...">GWSResender</a> maintains the sent messages (where a reply is expected). When no response or ack is received on time, such message is sent again.  
 <a href="classBeeeOn_1_1GWSResender.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="GWSResender_8h_source.html">GWSResender.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BeeeOn::GWSResender:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBeeeOn_1_1GWSResender.png" usemap="#BeeeOn::GWSResender_map" alt=""/>
  <map id="BeeeOn::GWSResender_map" name="BeeeOn::GWSResender_map">
<area href="classBeeeOn_1_1StoppableRunnable.html" alt="BeeeOn::StoppableRunnable" shape="rect" coords="0,56,173,80"/>
<area href="classBeeeOn_1_1GWSListener.html" title="GWSListener provides an interface for delivering of events and messages related to communication with..." alt="BeeeOn::GWSListener" shape="rect" coords="183,56,356,80"/>
<area href="classBeeeOn_1_1Loggable.html" alt="BeeeOn::Loggable" shape="rect" coords="366,56,539,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa15e6f6db929f18ac408e46e0601433"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa15e6f6db929f18ac408e46e0601433"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setConnector</b> (GWSConnector::Ptr connector)</td></tr>
<tr class="separator:afa15e6f6db929f18ac408e46e0601433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad407b376066a9cbdd18f70bd5a5a37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acad407b376066a9cbdd18f70bd5a5a37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#acad407b376066a9cbdd18f70bd5a5a37">setResendTimeout</a> (const Poco::Timespan &amp;timeout)</td></tr>
<tr class="memdesc:acad407b376066a9cbdd18f70bd5a5a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure timeout used to delay each resend. <br/></td></tr>
<tr class="separator:acad407b376066a9cbdd18f70bd5a5a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa258dfdfb694199ac40f699d4b954969"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa258dfdfb694199ac40f699d4b954969"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#aa258dfdfb694199ac40f699d4b954969">run</a> () override</td></tr>
<tr class="memdesc:aa258dfdfb694199ac40f699d4b954969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement scheduler of the waiting messages. <br/></td></tr>
<tr class="separator:aa258dfdfb694199ac40f699d4b954969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5b87e5f1db5acc83f50481bfd19d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#aac5b87e5f1db5acc83f50481bfd19d4d">stop</a> () override</td></tr>
<tr class="separator:aac5b87e5f1db5acc83f50481bfd19d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae6da8d87ee3ab1fdde6f61add177bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae6da8d87ee3ab1fdde6f61add177bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#a2ae6da8d87ee3ab1fdde6f61add177bf">onTrySend</a> (const GWMessage::Ptr message) override</td></tr>
<tr class="memdesc:a2ae6da8d87ee3ab1fdde6f61add177bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fire when a message is about to be sent to the server. After the send is successful (no network failure), the GWSListener::onSend() event would be generated as well. <br/></td></tr>
<tr class="separator:a2ae6da8d87ee3ab1fdde6f61add177bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addab80fbc703ce71d0e496c2da669628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#addab80fbc703ce71d0e496c2da669628">onSent</a> (const GWMessage::Ptr message) override</td></tr>
<tr class="memdesc:addab80fbc703ce71d0e496c2da669628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the given message into the waiting list if it is re-sendable. After resendTimeout, such message is send again unless an appropriate response/ack has been delivered.  <a href="#addab80fbc703ce71d0e496c2da669628">More...</a><br/></td></tr>
<tr class="separator:addab80fbc703ce71d0e496c2da669628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fa435d87960eb1fd2a94123d6bef0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1fa435d87960eb1fd2a94123d6bef0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#ad1fa435d87960eb1fd2a94123d6bef0c">onResponse</a> (const GWResponse::Ptr response) override</td></tr>
<tr class="memdesc:ad1fa435d87960eb1fd2a94123d6bef0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a response is received, this event is fired. <br/></td></tr>
<tr class="separator:ad1fa435d87960eb1fd2a94123d6bef0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f8d6716f120fe149543394fd62ed50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f8d6716f120fe149543394fd62ed50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#a50f8d6716f120fe149543394fd62ed50">onAck</a> (const GWAck::Ptr ack) override</td></tr>
<tr class="memdesc:a50f8d6716f120fe149543394fd62ed50"><td class="mdescLeft">&#160;</td><td class="mdescRight">When an ack is received, this event is fired. <br/></td></tr>
<tr class="separator:a50f8d6716f120fe149543394fd62ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc03eea33feb30b099e25d85d8fb99a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc03eea33feb30b099e25d85d8fb99a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#acc03eea33feb30b099e25d85d8fb99a3">onOther</a> (const GWMessage::Ptr message) override</td></tr>
<tr class="memdesc:acc03eea33feb30b099e25d85d8fb99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process <a class="el" href="classBeeeOn_1_1GWSensorDataConfirm.html" title="Represents message sent by the server to the gateway intended to confirm, that the server accepted ex...">GWSensorDataConfirm</a> messages. <br/></td></tr>
<tr class="separator:acc03eea33feb30b099e25d85d8fb99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBeeeOn_1_1GWSListener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classBeeeOn_1_1GWSListener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBeeeOn_1_1GWSListener.html">BeeeOn::GWSListener</a></td></tr>
<tr class="memitem:af6af80fe559104f7ac4d7fd825ceaa86 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6af80fe559104f7ac4d7fd825ceaa86"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSListener.html#af6af80fe559104f7ac4d7fd825ceaa86">onConnected</a> (const <a class="el" href="structBeeeOn_1_1GWSListener_1_1Address.html">Address</a> &amp;address)</td></tr>
<tr class="memdesc:af6af80fe559104f7ac4d7fd825ceaa86 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fired when the connection to the remote server is successfully created and it is possible to exchange messages. <br/></td></tr>
<tr class="separator:af6af80fe559104f7ac4d7fd825ceaa86 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d07db70033bc4766c1335e43824d31 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8d07db70033bc4766c1335e43824d31"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSListener.html#ab8d07db70033bc4766c1335e43824d31">onDisconnected</a> (const <a class="el" href="structBeeeOn_1_1GWSListener_1_1Address.html">Address</a> &amp;address)</td></tr>
<tr class="memdesc:ab8d07db70033bc4766c1335e43824d31 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fired when the connection to the remote server is considered broken or when it is disconnected on a request. <br/></td></tr>
<tr class="separator:ab8d07db70033bc4766c1335e43824d31 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cd01b303c05a3e6cc10cb260b20ad2 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53cd01b303c05a3e6cc10cb260b20ad2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSListener.html#a53cd01b303c05a3e6cc10cb260b20ad2">onRequest</a> (const GWRequest::Ptr request)</td></tr>
<tr class="memdesc:a53cd01b303c05a3e6cc10cb260b20ad2 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a request is received, this event is fired. <br/></td></tr>
<tr class="separator:a53cd01b303c05a3e6cc10cb260b20ad2 inherit pub_methods_classBeeeOn_1_1GWSListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a33227ea39efa7bab506a36a046a33930"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33227ea39efa7bab506a36a046a33930"></a>
typedef std::multimap<br class="typebreak"/>
&lt; Poco::Clock, GWMessage::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WaitingList</b></td></tr>
<tr class="separator:a33227ea39efa7bab506a36a046a33930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a60fddc3bc9357068909ef89797c7e137"><td class="memItemLeft" align="right" valign="top">WaitingList::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#a60fddc3bc9357068909ef89797c7e137">resendOrGet</a> (const Poco::Clock &amp;now)</td></tr>
<tr class="memdesc:a60fddc3bc9357068909ef89797c7e137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resend the oldest message waiting for resend if its timeout has expired.  <a href="#a60fddc3bc9357068909ef89797c7e137">More...</a><br/></td></tr>
<tr class="separator:a60fddc3bc9357068909ef89797c7e137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5038e5d114429b94718c8cac83a025"><td class="memItemLeft" align="right" valign="top">WaitingList &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#a5c5038e5d114429b94718c8cac83a025">waiting</a> ()</td></tr>
<tr class="separator:a5c5038e5d114429b94718c8cac83a025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc888597efd30ec3bf4f03c0a3d2389d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#afc888597efd30ec3bf4f03c0a3d2389d">resendable</a> (const GWMessage::Ptr message) const </td></tr>
<tr class="memdesc:afc888597efd30ec3bf4f03c0a3d2389d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Certain messages should be resended when there is no response/ack during the resendTimeout period. This applies to requests, responses with ack and sensor-data-export.  <a href="#afc888597efd30ec3bf4f03c0a3d2389d">More...</a><br/></td></tr>
<tr class="separator:afc888597efd30ec3bf4f03c0a3d2389d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fb15176591e9744cbfe286702eb0ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86fb15176591e9744cbfe286702eb0ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1GWSResender.html#a86fb15176591e9744cbfe286702eb0ab">findAndDrop</a> (const GWMessage::Ptr message)</td></tr>
<tr class="memdesc:a86fb15176591e9744cbfe286702eb0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the given message in the waiting list and remove it. Such message is considered as delivered or gracefully failed. <br/></td></tr>
<tr class="separator:a86fb15176591e9744cbfe286702eb0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classBeeeOn_1_1StoppableRunnable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classBeeeOn_1_1StoppableRunnable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classBeeeOn_1_1StoppableRunnable.html">BeeeOn::StoppableRunnable</a></td></tr>
<tr class="memitem:a1eec97b9474165b195a46fb836dd5da4 inherit pub_types_classBeeeOn_1_1StoppableRunnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eec97b9474165b195a46fb836dd5da4"></a>
typedef Poco::SharedPtr<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1StoppableRunnable.html">StoppableRunnable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:a1eec97b9474165b195a46fb836dd5da4 inherit pub_types_classBeeeOn_1_1StoppableRunnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classBeeeOn_1_1GWSListener"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classBeeeOn_1_1GWSListener')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classBeeeOn_1_1GWSListener.html">BeeeOn::GWSListener</a></td></tr>
<tr class="memitem:aa3646425ece8a8e1e1cccffb433581a5 inherit pub_types_classBeeeOn_1_1GWSListener"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3646425ece8a8e1e1cccffb433581a5"></a>
typedef Poco::SharedPtr<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1GWSListener.html">GWSListener</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:aa3646425ece8a8e1e1cccffb433581a5 inherit pub_types_classBeeeOn_1_1GWSListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Sending of messages via a <a class="el" href="classBeeeOn_1_1GWSConnector.html" title="GWSConnector is an abstract class that defines an API for communication with a remote server...">GWSConnector</a> might not be reliable. Messages that have been sent can never reach the remote server. The <a class="el" href="classBeeeOn_1_1GWSResender.html" title="Sending of messages via a GWSConnector might not be reliable. Messages that have been sent can never ...">GWSResender</a> maintains the sent messages (where a reply is expected). When no response or ack is received on time, such message is sent again. </p>
<p>If a message of an existing ID is to be resent, it replaces the previous message of the same ID scheduled for resent. Thus, only the most recent message of the same ID is always scheduled. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="addab80fbc703ce71d0e496c2da669628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GWSResender::onSent </td>
          <td>(</td>
          <td class="paramtype">const GWMessage::Ptr&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the given message into the waiting list if it is re-sendable. After resendTimeout, such message is send again unless an appropriate response/ack has been delivered. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classBeeeOn_1_1GWSResender.html#afc888597efd30ec3bf4f03c0a3d2389d" title="Certain messages should be resended when there is no response/ack during the resendTimeout period...">GWSResender::resendable()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classBeeeOn_1_1GWSListener.html#a0ae58d92489928a023a4ad0456956946">BeeeOn::GWSListener</a>.</p>

</div>
</div>
<a class="anchor" id="afc888597efd30ec3bf4f03c0a3d2389d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GWSResender::resendable </td>
          <td>(</td>
          <td class="paramtype">const GWMessage::Ptr&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Certain messages should be resended when there is no response/ack during the resendTimeout period. This applies to requests, responses with ack and sensor-data-export. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the given message is re-sendable. </dd></dl>

</div>
</div>
<a class="anchor" id="a60fddc3bc9357068909ef89797c7e137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GWSResender::WaitingList::const_iterator GWSResender::resendOrGet </td>
          <td>(</td>
          <td class="paramtype">const Poco::Clock &amp;&#160;</td>
          <td class="paramname"><em>now</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resend the oldest message waiting for resend if its timeout has expired. </p>
<dl class="section return"><dt>Returns</dt><dd>the oldest message that is to be resent </dd></dl>

</div>
</div>
<a class="anchor" id="aac5b87e5f1db5acc83f50481bfd19d4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GWSResender::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop the runnable. The call should not block. </p>

<p>Implements <a class="el" href="classBeeeOn_1_1StoppableRunnable.html#ad637a7273d906652c230c1e3aa2f6c7c">BeeeOn::StoppableRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="a5c5038e5d114429b94718c8cac83a025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GWSResender::WaitingList &amp; GWSResender::waiting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the container of waiting messages </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/server/<a class="el" href="GWSResender_8h_source.html">GWSResender.h</a></li>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/server/GWSResender.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
