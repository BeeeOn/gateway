<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BeeeOn Gateway: BeeeOn::DeviceManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Gateway
   &#160;<span id="projectnumber">v2018.12.1-rc1-15-gcf05ba1</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BeeeOn</b></li><li class="navelem"><a class="el" href="classBeeeOn_1_1DeviceManager.html">DeviceManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">BeeeOn::DeviceManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DeviceManager_8h_source.html">DeviceManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BeeeOn::DeviceManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBeeeOn_1_1DeviceManager.png" usemap="#BeeeOn::DeviceManager_map" alt=""/>
  <map id="BeeeOn::DeviceManager_map" name="BeeeOn::DeviceManager_map">
<area href="classBeeeOn_1_1CommandHandler.html" alt="BeeeOn::CommandHandler" shape="rect" coords="0,56,223,80"/>
<area href="classBeeeOn_1_1CommandSender.html" alt="BeeeOn::CommandSender" shape="rect" coords="233,56,456,80"/>
<area href="classBeeeOn_1_1DeviceStatusHandler.html" title="DeviceStatusHandler represents a class that can process status of a set of devices. This is useful when fetching pairing state from a remote server. " alt="BeeeOn::DeviceStatusHandler" shape="rect" coords="466,56,689,80"/>
<area href="classBeeeOn_1_1Loggable.html" alt="BeeeOn::Loggable" shape="rect" coords="699,56,922,80"/>
<area href="classBeeeOn_1_1StoppableRunnable.html" alt="BeeeOn::StoppableRunnable" shape="rect" coords="932,56,1155,80"/>
<area href="classBeeeOn_1_1BelkinWemoDeviceManager.html" alt="BeeeOn::BelkinWemoDeviceManager" shape="rect" coords="699,168,922,192"/>
<area href="classBeeeOn_1_1DongleDeviceManager.html" alt="BeeeOn::DongleDeviceManager" shape="rect" coords="699,224,922,248"/>
<area href="classBeeeOn_1_1FitpDeviceManager.html" alt="BeeeOn::FitpDeviceManager" shape="rect" coords="699,280,922,304"/>
<area href="classBeeeOn_1_1JablotronDeviceManager.html" title="JablotronDeviceManager utilizes the JablotronController to communicate with a Turris Dongle to receiv..." alt="BeeeOn::JablotronDeviceManager" shape="rect" coords="699,336,922,360"/>
<area href="classBeeeOn_1_1PhilipsHueDeviceManager.html" title="The class implements the work with Philips Hue bulbs. Allows us to process and execute the commands f..." alt="BeeeOn::PhilipsHueDeviceManager" shape="rect" coords="699,392,922,416"/>
<area href="classBeeeOn_1_1PressureSensorManager.html" alt="BeeeOn::PressureSensorManager" shape="rect" coords="699,448,922,472"/>
<area href="classBeeeOn_1_1VirtualDeviceManager.html" alt="BeeeOn::VirtualDeviceManager" shape="rect" coords="699,504,922,528"/>
<area href="classBeeeOn_1_1VPTDeviceManager.html" title="The class implements the work with Regulators VPT LAN v1.0. Allows us to process and execute the comm..." alt="BeeeOn::VPTDeviceManager" shape="rect" coords="699,560,922,584"/>
<area href="classBeeeOn_1_1ZWaveDeviceManager.html" title="ZWaveDeviceManager implements the logical layer on top of the ZWaveNetwork interface. It adapts the Z-Wave specifics to the BeeeOn system with the help of ZWaveMapperRegistry::Mapper. " alt="BeeeOn::ZWaveDeviceManager" shape="rect" coords="699,616,922,640"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a51e9e1a992248ac16f20a8c2e6672115"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51e9e1a992248ac16f20a8c2e6672115"></a>
typedef Poco::SharedPtr<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1DeviceManager.html">DeviceManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:a51e9e1a992248ac16f20a8c2e6672115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classBeeeOn_1_1DeviceStatusHandler"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classBeeeOn_1_1DeviceStatusHandler')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classBeeeOn_1_1DeviceStatusHandler.html">BeeeOn::DeviceStatusHandler</a></td></tr>
<tr class="memitem:a6025d29d22e8cdc76c39d6709ee100e4 inherit pub_types_classBeeeOn_1_1DeviceStatusHandler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6025d29d22e8cdc76c39d6709ee100e4"></a>
typedef Poco::SharedPtr<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1DeviceStatusHandler.html">DeviceStatusHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:a6025d29d22e8cdc76c39d6709ee100e4 inherit pub_types_classBeeeOn_1_1DeviceStatusHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c6f5e9efcc333f216d4ad526eadca inherit pub_types_classBeeeOn_1_1DeviceStatusHandler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad06c6f5e9efcc333f216d4ad526eadca"></a>
typedef std::map&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a>, <br class="typebreak"/>
std::map&lt; <a class="el" href="classBeeeOn_1_1ModuleID.html">ModuleID</a>, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceValues</b></td></tr>
<tr class="separator:ad06c6f5e9efcc333f216d4ad526eadca inherit pub_types_classBeeeOn_1_1DeviceStatusHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67184ffd5cd51ee3b5ef208c4add70b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67184ffd5cd51ee3b5ef208c4add70b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceManager</b> (const <a class="el" href="classBeeeOn_1_1Enum.html">DevicePrefix</a> &amp;<a class="el" href="classBeeeOn_1_1DeviceManager.html#a5409f8a69e76bd6b33b9b5ceffe18ba4">prefix</a>, const std::initializer_list&lt; std::type_index &gt; &amp;acceptable={})</td></tr>
<tr class="separator:a67184ffd5cd51ee3b5ef208c4add70b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5409f8a69e76bd6b33b9b5ceffe18ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBeeeOn_1_1Enum.html">DevicePrefix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a5409f8a69e76bd6b33b9b5ceffe18ba4">prefix</a> () const override</td></tr>
<tr class="separator:a5409f8a69e76bd6b33b9b5ceffe18ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26f2187e2ed239017ceb3a530a8e9dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#ac26f2187e2ed239017ceb3a530a8e9dd">stop</a> () override</td></tr>
<tr class="separator:ac26f2187e2ed239017ceb3a530a8e9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7268426252429a979e64d77881bcbbd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7268426252429a979e64d77881bcbbd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDeviceCache</b> (DeviceCache::Ptr cache)</td></tr>
<tr class="separator:a7268426252429a979e64d77881bcbbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834fa16d05b841aee857033e96bb47d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834fa16d05b841aee857033e96bb47d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDistributor</b> (Poco::SharedPtr&lt; <a class="el" href="classBeeeOn_1_1Distributor.html">Distributor</a> &gt; distributor)</td></tr>
<tr class="separator:a834fa16d05b841aee857033e96bb47d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d23d839a37a8654bee7e85073274c7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a7d23d839a37a8654bee7e85073274c7c">accept</a> (const Command::Ptr cmd) override</td></tr>
<tr class="separator:a7d23d839a37a8654bee7e85073274c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37056670e4209fa7d272d26943203aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#af37056670e4209fa7d272d26943203aa">handle</a> (Command::Ptr cmd, Answer::Ptr answer) override</td></tr>
<tr class="separator:af37056670e4209fa7d272d26943203aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73591fe2ec1364a5b973057fcb37b51e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73591fe2ec1364a5b973057fcb37b51e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a73591fe2ec1364a5b973057fcb37b51e">handleRemoteStatus</a> (const <a class="el" href="classBeeeOn_1_1Enum.html">DevicePrefix</a> &amp;<a class="el" href="classBeeeOn_1_1DeviceManager.html#a5409f8a69e76bd6b33b9b5ceffe18ba4">prefix</a>, const std::set&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt; &amp;devices, const DeviceStatusHandler::DeviceValues &amp;values) override</td></tr>
<tr class="memdesc:a73591fe2ec1364a5b973057fcb37b51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when devices from a remote server are fetched and so the pairing status of them can be reconsidered. The default implementation just updates the device cache appropriately. <br/></td></tr>
<tr class="separator:a73591fe2ec1364a5b973057fcb37b51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBeeeOn_1_1CommandSender"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classBeeeOn_1_1CommandSender')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBeeeOn_1_1CommandSender.html">BeeeOn::CommandSender</a></td></tr>
<tr class="memitem:a253245ba6a7af4fb671b3182beaccf6a inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1CommandSender.html#a253245ba6a7af4fb671b3182beaccf6a">setCommandDispatcher</a> (<a class="el" href="classBeeeOn_1_1CommandDispatcher.html">CommandDispatcher</a> *dispatcher)</td></tr>
<tr class="separator:a253245ba6a7af4fb671b3182beaccf6a inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf881083d28284f9b4d5542f1d47899a inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1CommandSender.html#aaf881083d28284f9b4d5542f1d47899a">dispatch</a> (Poco::AutoPtr&lt; <a class="el" href="classBeeeOn_1_1Command.html">Command</a> &gt; cmd, Poco::AutoPtr&lt; <a class="el" href="classBeeeOn_1_1Answer.html">Answer</a> &gt; answer)</td></tr>
<tr class="separator:aaf881083d28284f9b4d5542f1d47899a inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2013cf12aed8921ddcf2a5458de6b5d4 inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1CommandSender.html#a2013cf12aed8921ddcf2a5458de6b5d4">dispatch</a> (Poco::AutoPtr&lt; <a class="el" href="classBeeeOn_1_1Command.html">Command</a> &gt; cmd)</td></tr>
<tr class="separator:a2013cf12aed8921ddcf2a5458de6b5d4 inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb29da373ec3a909daa01614a0b7116 inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBeeeOn_1_1AnswerQueue.html">AnswerQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1CommandSender.html#aabb29da373ec3a909daa01614a0b7116">answerQueue</a> ()</td></tr>
<tr class="separator:aabb29da373ec3a909daa01614a0b7116 inherit pub_methods_classBeeeOn_1_1CommandSender"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abd40493771aabb83d6ee3d85bf5dc542"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#abd40493771aabb83d6ee3d85bf5dc542">waitRemoteStatus</a> (const Poco::Timespan &amp;timeout)</td></tr>
<tr class="memdesc:abd40493771aabb83d6ee3d85bf5dc542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the remote status is delivered or timeout exceeds. DO NOT USE this method, it is intended as a transition mechanism from calling of the deprecated method deviceList().  <a href="#abd40493771aabb83d6ee3d85bf5dc542">More...</a><br/></td></tr>
<tr class="separator:abd40493771aabb83d6ee3d85bf5dc542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0a5e70736672b26a1669d2b11eaa73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#afd0a5e70736672b26a1669d2b11eaa73">handleGeneric</a> (const Command::Ptr cmd, Result::Ptr result)</td></tr>
<tr class="separator:afd0a5e70736672b26a1669d2b11eaa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d93d732c2fd1816cb952d2a469c70f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d93d732c2fd1816cb952d2a469c70f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#ab6d93d732c2fd1816cb952d2a469c70f">handleAccept</a> (const DeviceAcceptCommand::Ptr)</td></tr>
<tr class="memdesc:ab6d93d732c2fd1816cb952d2a469c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic handler of the <a class="el" href="classBeeeOn_1_1DeviceAcceptCommand.html">DeviceAcceptCommand</a>. It might be helpful to override this method in case we need to make some technology-specific check of the device to be accepted. The default implementation simply marks the given device as paired. <br/></td></tr>
<tr class="separator:ab6d93d732c2fd1816cb952d2a469c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f32abaac4ec4840bcd0e150e7cf3f7"><td class="memItemLeft" align="right" valign="top">virtual AsyncWork::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a56f32abaac4ec4840bcd0e150e7cf3f7">startDiscovery</a> (const Poco::Timespan &amp;timeout)</td></tr>
<tr class="memdesc:a56f32abaac4ec4840bcd0e150e7cf3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts device discovery process in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself).  <a href="#a56f32abaac4ec4840bcd0e150e7cf3f7">More...</a><br/></td></tr>
<tr class="separator:a56f32abaac4ec4840bcd0e150e7cf3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0239fe377b5928e3bbf5986f15017916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a0239fe377b5928e3bbf5986f15017916">handleListen</a> (const GatewayListenCommand::Ptr cmd)</td></tr>
<tr class="memdesc:a0239fe377b5928e3bbf5986f15017916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements handling of the listen command in a generic way. The method ensures that only 1 thread can execute the discovery process at a time.  <a href="#a0239fe377b5928e3bbf5986f15017916">More...</a><br/></td></tr>
<tr class="separator:a0239fe377b5928e3bbf5986f15017916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0924c9ad198c04f2b051041a41831eec"><td class="memItemLeft" align="right" valign="top">virtual AsyncWork::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a0924c9ad198c04f2b051041a41831eec">startSearch</a> (const Poco::Timespan &amp;timeout, const Poco::Net::IPAddress &amp;address)</td></tr>
<tr class="memdesc:a0924c9ad198c04f2b051041a41831eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start searching a device by IP address in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself).  <a href="#a0924c9ad198c04f2b051041a41831eec">More...</a><br/></td></tr>
<tr class="separator:a0924c9ad198c04f2b051041a41831eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b1b2ebd078a3f91dc30e080d704325"><td class="memItemLeft" align="right" valign="top">virtual AsyncWork::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a17b1b2ebd078a3f91dc30e080d704325">startSearch</a> (const Poco::Timespan &amp;timeout, const <a class="el" href="classBeeeOn_1_1MACAddress.html">MACAddress</a> &amp;address)</td></tr>
<tr class="memdesc:a17b1b2ebd078a3f91dc30e080d704325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start searching a device by MAC address in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself).  <a href="#a17b1b2ebd078a3f91dc30e080d704325">More...</a><br/></td></tr>
<tr class="separator:a17b1b2ebd078a3f91dc30e080d704325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1899333f2d948275c4dec4a99ffef6"><td class="memItemLeft" align="right" valign="top">virtual AsyncWork::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a5f1899333f2d948275c4dec4a99ffef6">startSearch</a> (const Poco::Timespan &amp;timeout, const uint64_t serialNumber)</td></tr>
<tr class="memdesc:a5f1899333f2d948275c4dec4a99ffef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start searching a device by serial number in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself).  <a href="#a5f1899333f2d948275c4dec4a99ffef6">More...</a><br/></td></tr>
<tr class="separator:a5f1899333f2d948275c4dec4a99ffef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fda5c7d7b5ba7fcc589a851f46213a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06fda5c7d7b5ba7fcc589a851f46213a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a06fda5c7d7b5ba7fcc589a851f46213a">handleSearch</a> (const DeviceSearchCommand::Ptr cmd)</td></tr>
<tr class="memdesc:a06fda5c7d7b5ba7fcc589a851f46213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements handling of the search command in a generic way. The method ensures that only 1 thread can exactly the search process at a time. It is also mutual exclusive to the discovery process. <br/></td></tr>
<tr class="separator:a06fda5c7d7b5ba7fcc589a851f46213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0304177883d9b37b4a49f93d74a5c313"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a>&lt; std::set<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt; &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a0304177883d9b37b4a49f93d74a5c313">startUnpair</a> (const <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &amp;id, const Poco::Timespan &amp;timeout)</td></tr>
<tr class="memdesc:a0304177883d9b37b4a49f93d74a5c313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts device unpair process in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself).  <a href="#a0304177883d9b37b4a49f93d74a5c313">More...</a><br/></td></tr>
<tr class="separator:a0304177883d9b37b4a49f93d74a5c313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd80dc1d719797f57e7c854426855beb"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#abd80dc1d719797f57e7c854426855beb">handleUnpair</a> (const DeviceUnpairCommand::Ptr cmd)</td></tr>
<tr class="memdesc:abd80dc1d719797f57e7c854426855beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements handling of the unpair command in a generic way. The method ensures that only 1 thread can execute the unpair process at a time.  <a href="#abd80dc1d719797f57e7c854426855beb">More...</a><br/></td></tr>
<tr class="separator:abd80dc1d719797f57e7c854426855beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a460e34e2891288c80c2a18adb4aa7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a>&lt; double &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a2a460e34e2891288c80c2a18adb4aa7d">startSetValue</a> (const <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &amp;id, const <a class="el" href="classBeeeOn_1_1ModuleID.html">ModuleID</a> &amp;module, const double value, const Poco::Timespan &amp;timeout)</td></tr>
<tr class="memdesc:a2a460e34e2891288c80c2a18adb4aa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts set-value operation in a technology specific way. The method is always called inside a critical section and so its implementation does not have to be thread-save nor reentrant (unless it cooperates with other threads itself).  <a href="#a2a460e34e2891288c80c2a18adb4aa7d">More...</a><br/></td></tr>
<tr class="separator:a2a460e34e2891288c80c2a18adb4aa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa94b73d5a590bf1ef77a504f7a14ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a7aa94b73d5a590bf1ef77a504f7a14ab">handleSetValue</a> (const DeviceSetValueCommand::Ptr cmd)</td></tr>
<tr class="memdesc:a7aa94b73d5a590bf1ef77a504f7a14ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements handling of the set-value command in a generic way. The method ensures that only 1 thread can execute set-value process at a time. If the set-value operation succeeds, it ships the set value.  <a href="#a7aa94b73d5a590bf1ef77a504f7a14ab">More...</a><br/></td></tr>
<tr class="separator:a7aa94b73d5a590bf1ef77a504f7a14ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e2b5abe52d5db31a0c4b28bcc52f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a94e2b5abe52d5db31a0c4b28bcc52f80">ship</a> (const <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &amp;sensorData)</td></tr>
<tr class="separator:a94e2b5abe52d5db31a0c4b28bcc52f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d625a519fb488eaddc38ad42b0791e"><td class="memItemLeft" align="right" valign="top">DeviceCache::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a39d625a519fb488eaddc38ad42b0791e">deviceCache</a> () const </td></tr>
<tr class="separator:a39d625a519fb488eaddc38ad42b0791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ae734dddde1a3466a801fe23b18818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBeeeOn_1_1CancellableSet.html">CancellableSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#ae7ae734dddde1a3466a801fe23b18818">cancellable</a> ()</td></tr>
<tr class="separator:ae7ae734dddde1a3466a801fe23b18818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92f8ba6dc2c359daacb8d47519fda30"><td class="memItemLeft" align="right" valign="top">Poco::Timespan&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#ae92f8ba6dc2c359daacb8d47519fda30">checkDelayedOperation</a> (const std::string &amp;opname, const Poco::Clock &amp;started, const Poco::Timespan &amp;duration) const </td></tr>
<tr class="memdesc:ae92f8ba6dc2c359daacb8d47519fda30"><td class="mdescLeft">&#160;</td><td class="mdescRight">When starting an asynchronous operation, it might happen we sleep too long on a lock because the previous operation did not finished yet. This method performs such checks and also tests for global stop request. If everything is in order it just fixes the duration by the time elapsed by waiting. Otherwise, it throws an exception.  <a href="#ae92f8ba6dc2c359daacb8d47519fda30">More...</a><br/></td></tr>
<tr class="separator:ae92f8ba6dc2c359daacb8d47519fda30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a7f4fd33589018e747a219114a37ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1DeviceManager.html#a10a7f4fd33589018e747a219114a37ba">manageUntilFinished</a> (const std::string &amp;opname, AnyAsyncWork::Ptr work, const Poco::Timespan &amp;timeout)</td></tr>
<tr class="memdesc:a10a7f4fd33589018e747a219114a37ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage an <a class="el" href="classBeeeOn_1_1AsyncWork.html" title="AsyncWork is an interface allowing to wait until an asynchronous operation finishes. It is also possible to force-stop it by calling cancel(). ">AsyncWork</a> after it is started. If it does not finish in the given timeout, it is cancelled explicitly.  <a href="#a10a7f4fd33589018e747a219114a37ba">More...</a><br/></td></tr>
<tr class="separator:a10a7f4fd33589018e747a219114a37ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89c60789e75cb07103e46d40a3ebb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setupLogger</b> (Poco::Logger *logger=0) const </td></tr>
<tr class="separator:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f8405547e70200fe594a24906d7e7e"></a>
Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>logger</b> () const </td></tr>
<tr class="separator:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28780034cab771631dfb4db98a7954bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba38a43bcc45e65dfb6455ad8ad2e1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1ea9cbbb0aee2f7e356fe8a8c5f8bf3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ea9cbbb0aee2f7e356fe8a8c5f8bf3e"></a>
<a class="el" href="classBeeeOn_1_1StopControl.html">StopControl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_stopControl</b></td></tr>
<tr class="separator:a1ea9cbbb0aee2f7e356fe8a8c5f8bf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93889eade4537aea6abb3f383a8463e"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forMethod</b> (const char *name)</td></tr>
<tr class="separator:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a559c00fe671201e7ee5cebf19706491d"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99f58cf545bb5550c42fbb75d4645c4a"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ddc275e696705f0e68a5332d2cd5960"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplItemLeft" align="right" valign="top">static Poco::Logger &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forInstance</b> (const T *i)</td></tr>
<tr class="separator:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c03d407c8269d8fc9f71f0161ae17ae"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>configureSimple</b> (Poco::Logger &amp;logger, const std::string &amp;level)</td></tr>
<tr class="separator:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ab586b4bd8f9f97552e475a008db44 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ab586b4bd8f9f97552e475a008db44"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>logException</b> (Poco::Logger &amp;logger, const Poco::Message::Priority priority, const Poco::Exception &amp;e, const char *file, size_t line)</td></tr>
<tr class="separator:ad5ab586b4bd8f9f97552e475a008db44 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>All classes that manage devices should inherit from this abstract class. It provides a common functionality for this purpose.</p>
<p>There is usually a main thread that performs communication with the physical devices and translates the specific device communication protocol into the <a class="el" href="classBeeeOn_1_1Command.html">Command</a> &amp; <a class="el" href="classBeeeOn_1_1Answer.html">Answer</a> interface or into <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> interface.</p>
<p>Communication in the direction to physical devices is served via the <a class="el" href="classBeeeOn_1_1CommandHandler.html">CommandHandler</a> interface. By accepting Commands asking for specific tasks, the physical devices can be queried as expected by the server. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7d23d839a37a8654bee7e85073274c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DeviceManager::accept </td>
          <td>(</td>
          <td class="paramtype">const Command::Ptr&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic implementation of the CommandHandler::accept() method. If the m_acceptable set is initialized appropriately, this generic implementation can be used directly. </p>

<p>Implements <a class="el" href="classBeeeOn_1_1CommandHandler.html">BeeeOn::CommandHandler</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ae734dddde1a3466a801fe23b18818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBeeeOn_1_1CancellableSet.html">CancellableSet</a> &amp; DeviceManager::cancellable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reference to the <a class="el" href="classBeeeOn_1_1CancellableSet.html">CancellableSet</a> instance that is cancelled on <a class="el" href="classBeeeOn_1_1DeviceManager.html#ac26f2187e2ed239017ceb3a530a8e9dd">stop()</a>. This allows to manage asynchronous jobs and cancel them when required. </dd></dl>

</div>
</div>
<a class="anchor" id="ae92f8ba6dc2c359daacb8d47519fda30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Timespan DeviceManager::checkDelayedOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poco::Clock &amp;&#160;</td>
          <td class="paramname"><em>started</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When starting an asynchronous operation, it might happen we sleep too long on a lock because the previous operation did not finished yet. This method performs such checks and also tests for global stop request. If everything is in order it just fixes the duration by the time elapsed by waiting. Otherwise, it throws an exception. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>when stop has been requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39d625a519fb488eaddc38ad42b0791e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DeviceCache::Ptr DeviceManager::deviceCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the underlying <a class="el" href="classBeeeOn_1_1DeviceCache.html" title="DeviceCache manages pairing status devices which allows to choose different caching strategies like: ...">DeviceCache</a> instance </dd></dl>

</div>
</div>
<a class="anchor" id="af37056670e4209fa7d272d26943203aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceManager::handle </td>
          <td>(</td>
          <td class="paramtype">Command::Ptr&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Answer::Ptr&#160;</td>
          <td class="paramname"><em>answer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic implementation of the CommandHandler::handle() method. It works with respect to the <a class="el" href="classBeeeOn_1_1DeviceManager.html#a7d23d839a37a8654bee7e85073274c7c">accept()</a> method and handles commands generically if possible. It also catches all exceptions and fails such command executions properly.</p>
<p>To override handle, please use <a class="el" href="classBeeeOn_1_1DeviceManager.html#afd0a5e70736672b26a1669d2b11eaa73">handleGeneric()</a> instead. </p>

<p>Implements <a class="el" href="classBeeeOn_1_1CommandHandler.html">BeeeOn::CommandHandler</a>.</p>

</div>
</div>
<a class="anchor" id="afd0a5e70736672b26a1669d2b11eaa73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceManager::handleGeneric </td>
          <td>(</td>
          <td class="paramtype">const Command::Ptr&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result::Ptr&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic implementation of the <a class="el" href="classBeeeOn_1_1DeviceManager.html#af37056670e4209fa7d272d26943203aa">handle()</a>. If any device manager needs to override the <a class="el" href="classBeeeOn_1_1DeviceManager.html#af37056670e4209fa7d272d26943203aa">handle()</a> method, it is more desirable to override <a class="el" href="classBeeeOn_1_1DeviceManager.html#afd0a5e70736672b26a1669d2b11eaa73">handleGeneric()</a>. </p>

<p>Reimplemented in <a class="el" href="classBeeeOn_1_1FitpDeviceManager.html#a7c08d69eb9748fa9be0ade5adcf0ce2d">BeeeOn::FitpDeviceManager</a>, <a class="el" href="classBeeeOn_1_1VirtualDeviceManager.html#a8d1fd225729c980b0e465458795485a0">BeeeOn::VirtualDeviceManager</a>, <a class="el" href="classBeeeOn_1_1VPTDeviceManager.html#a40f7e75703a0e72df31bf6600dc595c3">BeeeOn::VPTDeviceManager</a>, <a class="el" href="classBeeeOn_1_1PhilipsHueDeviceManager.html#a19641de3e889b059f04f649c99c7ccaa">BeeeOn::PhilipsHueDeviceManager</a>, and <a class="el" href="classBeeeOn_1_1BelkinWemoDeviceManager.html#a87c359cfbc177a35ab43cb2b10779f2e">BeeeOn::BelkinWemoDeviceManager</a>.</p>

</div>
</div>
<a class="anchor" id="a0239fe377b5928e3bbf5986f15017916"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceManager::handleListen </td>
          <td>(</td>
          <td class="paramtype">const GatewayListenCommand::Ptr&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements handling of the listen command in a generic way. The method ensures that only 1 thread can execute the discovery process at a time. </p>
<p>It uses the method <a class="el" href="classBeeeOn_1_1DeviceManager.html#a56f32abaac4ec4840bcd0e150e7cf3f7" title="Starts device discovery process in a technology-specific way. This method is always called inside a c...">startDiscovery()</a> to initialize and start a new discovery process. It is guaranteed that the <a class="el" href="classBeeeOn_1_1DeviceManager.html#a56f32abaac4ec4840bcd0e150e7cf3f7" title="Starts device discovery process in a technology-specific way. This method is always called inside a c...">startDiscovery()</a> method is always called exactly once at a time and until it finishes, no other discovery is started. The minimal timeout for the discovery is at least 1 second which is enforced by the implementation. </p>

</div>
</div>
<a class="anchor" id="a7aa94b73d5a590bf1ef77a504f7a14ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceManager::handleSetValue </td>
          <td>(</td>
          <td class="paramtype">const DeviceSetValueCommand::Ptr&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements handling of the set-value command in a generic way. The method ensures that only 1 thread can execute set-value process at a time. If the set-value operation succeeds, it ships the set value. </p>
<p>It uses the method <a class="el" href="classBeeeOn_1_1DeviceManager.html#a2a460e34e2891288c80c2a18adb4aa7d" title="Starts set-value operation in a technology specific way. The method is always called inside a critica...">startSetValue()</a> to initialize and start the set-value process. The method <a class="el" href="classBeeeOn_1_1DeviceManager.html#a2a460e34e2891288c80c2a18adb4aa7d" title="Starts set-value operation in a technology specific way. The method is always called inside a critica...">startSetValue()</a> is always called exactly once at a time and until it finishes, no the set-value is started. </p>

</div>
</div>
<a class="anchor" id="abd80dc1d719797f57e7c854426855beb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt; DeviceManager::handleUnpair </td>
          <td>(</td>
          <td class="paramtype">const DeviceUnpairCommand::Ptr&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements handling of the unpair command in a generic way. The method ensures that only 1 thread can execute the unpair process at a time. </p>
<p>It uses the method <a class="el" href="classBeeeOn_1_1DeviceManager.html#a0304177883d9b37b4a49f93d74a5c313" title="Starts device unpair process in a technology-specific way. This method is always called inside a crit...">startUnpair()</a> to initialize and start the unpairing process. The method <a class="el" href="classBeeeOn_1_1DeviceManager.html#a0304177883d9b37b4a49f93d74a5c313" title="Starts device unpair process in a technology-specific way. This method is always called inside a crit...">startUnpair()</a> is always called exactly once at a time and until it finishes, no other unpair is started. </p>

</div>
</div>
<a class="anchor" id="a10a7f4fd33589018e747a219114a37ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DeviceManager::manageUntilFinished </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyAsyncWork::Ptr&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manage an <a class="el" href="classBeeeOn_1_1AsyncWork.html" title="AsyncWork is an interface allowing to wait until an asynchronous operation finishes. It is also possible to force-stop it by calling cancel(). ">AsyncWork</a> after it is started. If it does not finish in the given timeout, it is cancelled explicitly. </p>
<dl class="section return"><dt>Returns</dt><dd>false when cancellled (timeout) </dd></dl>

</div>
</div>
<a class="anchor" id="a5409f8a69e76bd6b33b9b5ceffe18ba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBeeeOn_1_1Enum.html">DevicePrefix</a> DeviceManager::prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>prefix managed by this device manager </dd></dl>

<p>Implements <a class="el" href="classBeeeOn_1_1DeviceStatusHandler.html#a605dc3957f326ce6969865efe8be041b">BeeeOn::DeviceStatusHandler</a>.</p>

</div>
</div>
<a class="anchor" id="a94e2b5abe52d5db31a0c4b28bcc52f80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceManager::ship </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &amp;&#160;</td>
          <td class="paramname"><em>sensorData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ship data received from a physical device into a collection point. </p>

</div>
</div>
<a class="anchor" id="a56f32abaac4ec4840bcd0e150e7cf3f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AsyncWork::Ptr DeviceManager::startDiscovery </td>
          <td>(</td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts device discovery process in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself). </p>
<p>The purpose of this call is to initialize and start the discovery process which might be a non-blocking operation. The caller uses the provided <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork&lt;&gt;</a> instance to wait until it finishes or to cancel it earlier if needed. </p>

<p>Reimplemented in <a class="el" href="classBeeeOn_1_1ZWaveDeviceManager.html#af5556ff25587a08547e44d954bdce497">BeeeOn::ZWaveDeviceManager</a>, <a class="el" href="classBeeeOn_1_1JablotronDeviceManager.html#a881a6b34314b8b6424925a2e97ba2b28">BeeeOn::JablotronDeviceManager</a>, <a class="el" href="classBeeeOn_1_1BLESmartDeviceManager.html#a1d48ec939e0009357c7536b0e8995266">BeeeOn::BLESmartDeviceManager</a>, <a class="el" href="classBeeeOn_1_1VPTDeviceManager.html#a6d1f261358207f6ab7857c03a2d59baf">BeeeOn::VPTDeviceManager</a>, <a class="el" href="classBeeeOn_1_1BluetoothAvailabilityManager.html#a6d7b023c1fc910893d284836ecae6a2d">BeeeOn::BluetoothAvailabilityManager</a>, <a class="el" href="classBeeeOn_1_1PhilipsHueDeviceManager.html#a3069546597cdb7b1b3746017209590b2">BeeeOn::PhilipsHueDeviceManager</a>, <a class="el" href="classBeeeOn_1_1PressureSensorManager.html#ace1e9322d79262107434a52e42212379">BeeeOn::PressureSensorManager</a>, and <a class="el" href="classBeeeOn_1_1BelkinWemoDeviceManager.html#a975040389d845e376664997aff1ad06b">BeeeOn::BelkinWemoDeviceManager</a>.</p>

</div>
</div>
<a class="anchor" id="a0924c9ad198c04f2b051041a41831eec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a> ::Ptr BeeeOn::DeviceManager::startSearch </td>
          <td>(</td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poco::Net::IPAddress &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start searching a device by IP address in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself). </p>
<p>The purpose of this call is to initialize and start the searching process which might be a non-blocking operation. The caller uses the provided <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork&lt;&gt;</a> instance to wait until it finishes or to cancel it earlier if needed. </p>

</div>
</div>
<a class="anchor" id="a17b1b2ebd078a3f91dc30e080d704325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a> ::Ptr BeeeOn::DeviceManager::startSearch </td>
          <td>(</td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBeeeOn_1_1MACAddress.html">MACAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start searching a device by MAC address in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself). </p>
<p>The purpose of this call is to initialize and start the searching process which might be a non-blocking operation. The caller uses the provided <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork&lt;&gt;</a> instance to wait until it finishes or to cancel it earlier if needed. </p>

</div>
</div>
<a class="anchor" id="a5f1899333f2d948275c4dec4a99ffef6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a> ::Ptr BeeeOn::DeviceManager::startSearch </td>
          <td>(</td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>serialNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start searching a device by serial number in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself). </p>
<p>The purpose of this call is to initialize and start the searching process which might be a non-blocking operation. The caller uses the provided <a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork&lt;&gt;</a> instance to wait until it finishes or to cancel it earlier if needed. </p>

<p>Reimplemented in <a class="el" href="classBeeeOn_1_1JablotronDeviceManager.html#a200888f0591f1a9869fcf05b626d9b43">BeeeOn::JablotronDeviceManager</a>.</p>

</div>
</div>
<a class="anchor" id="a2a460e34e2891288c80c2a18adb4aa7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a>&lt; double &gt;::Ptr DeviceManager::startSetValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBeeeOn_1_1ModuleID.html">ModuleID</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts set-value operation in a technology specific way. The method is always called inside a critical section and so its implementation does not have to be thread-save nor reentrant (unless it cooperates with other threads itself). </p>
<p>The set-value process might a be a non-blocking operation. The value set by the set-value is expected as a result of the returned <a class="el" href="classBeeeOn_1_1AsyncWork.html" title="AsyncWork is an interface allowing to wait until an asynchronous operation finishes. It is also possible to force-stop it by calling cancel(). ">AsyncWork</a> instance. </p>

<p>Reimplemented in <a class="el" href="classBeeeOn_1_1JablotronDeviceManager.html#a06a5aa5675e6d3082c05111e584e6935">BeeeOn::JablotronDeviceManager</a>, <a class="el" href="classBeeeOn_1_1ZWaveDeviceManager.html#a7b9be6c69c2342873ea82175a43e64bf">BeeeOn::ZWaveDeviceManager</a>, and <a class="el" href="classBeeeOn_1_1BLESmartDeviceManager.html#a557bcc34684e09588c0d0b3711092cd8">BeeeOn::BLESmartDeviceManager</a>.</p>

</div>
</div>
<a class="anchor" id="a0304177883d9b37b4a49f93d74a5c313"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBeeeOn_1_1AsyncWork.html">AsyncWork</a>&lt; set&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt; &gt;::Ptr DeviceManager::startUnpair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts device unpair process in a technology-specific way. This method is always called inside a critical section and so its implementation does not have to be thread-safe nor reentrant (unless it cooperates with other threads itself). </p>
<p>The unpairing process might be a non-blocking operation. The unpaired devices are provided via the result of the returned <a class="el" href="classBeeeOn_1_1AsyncWork.html" title="AsyncWork is an interface allowing to wait until an asynchronous operation finishes. It is also possible to force-stop it by calling cancel(). ">AsyncWork</a> instance. </p>

<p>Reimplemented in <a class="el" href="classBeeeOn_1_1JablotronDeviceManager.html#a471fa567d5f4dd28f9cbe5fb3457e5e4">BeeeOn::JablotronDeviceManager</a>, <a class="el" href="classBeeeOn_1_1ZWaveDeviceManager.html#adef548c10cdc0b842b6a036a1414b09e">BeeeOn::ZWaveDeviceManager</a>, <a class="el" href="classBeeeOn_1_1BLESmartDeviceManager.html#a449011ef2b93423b46ba3ec46af6f72f">BeeeOn::BLESmartDeviceManager</a>, <a class="el" href="classBeeeOn_1_1VPTDeviceManager.html#a36af3e994b74cb545025df2380309e9b">BeeeOn::VPTDeviceManager</a>, <a class="el" href="classBeeeOn_1_1BluetoothAvailabilityManager.html#ac1f8e64164ce4cde36b32a9731cdad3e">BeeeOn::BluetoothAvailabilityManager</a>, <a class="el" href="classBeeeOn_1_1PhilipsHueDeviceManager.html#a3414f89b277e758fa30ee60584208614">BeeeOn::PhilipsHueDeviceManager</a>, <a class="el" href="classBeeeOn_1_1PressureSensorManager.html#a9d565bb5022533350b47b22da4ab2395">BeeeOn::PressureSensorManager</a>, and <a class="el" href="classBeeeOn_1_1BelkinWemoDeviceManager.html#a21eb2106e4a7376c4cf15179e5af9a10">BeeeOn::BelkinWemoDeviceManager</a>.</p>

</div>
</div>
<a class="anchor" id="ac26f2187e2ed239017ceb3a530a8e9dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceManager::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A generic stop implementation to be used by most <a class="el" href="classBeeeOn_1_1DeviceManager.html">DeviceManager</a> implementations. </p>

<p>Implements <a class="el" href="classBeeeOn_1_1StoppableRunnable.html#ad637a7273d906652c230c1e3aa2f6c7c">BeeeOn::StoppableRunnable</a>.</p>

<p>Reimplemented in <a class="el" href="classBeeeOn_1_1ZWaveDeviceManager.html#ab0827462ce12a93fde8d47715a26a23e">BeeeOn::ZWaveDeviceManager</a>, <a class="el" href="classBeeeOn_1_1JablotronDeviceManager.html#a8b9286e194ee589921f8f72a4f041df8">BeeeOn::JablotronDeviceManager</a>, <a class="el" href="classBeeeOn_1_1FitpDeviceManager.html#a30a185200ddd558f9cbd3f13b475519c">BeeeOn::FitpDeviceManager</a>, <a class="el" href="classBeeeOn_1_1VPTDeviceManager.html#ab4dd110ff9a7c2294f448a8daa203f0b">BeeeOn::VPTDeviceManager</a>, <a class="el" href="classBeeeOn_1_1PhilipsHueDeviceManager.html#a733173bef96753cffbc4058833e575a6">BeeeOn::PhilipsHueDeviceManager</a>, <a class="el" href="classBeeeOn_1_1PressureSensorManager.html#a0c44ee6aa33b0a3210e8c612d94dfd50">BeeeOn::PressureSensorManager</a>, <a class="el" href="classBeeeOn_1_1VirtualDeviceManager.html#afa8424652f31f5952a4ddd86f472625f">BeeeOn::VirtualDeviceManager</a>, and <a class="el" href="classBeeeOn_1_1DongleDeviceManager.html#a2cb13d1a1515183d13731bf9208ee077">BeeeOn::DongleDeviceManager</a>.</p>

</div>
</div>
<a class="anchor" id="abd40493771aabb83d6ee3d85bf5dc542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classBeeeOn_1_1DeviceID.html">DeviceID</a> &gt; DeviceManager::waitRemoteStatus </td>
          <td>(</td>
          <td class="paramtype">const Poco::Timespan &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until the remote status is delivered or timeout exceeds. DO NOT USE this method, it is intended as a transition mechanism from calling of the deprecated method deviceList(). </p>
<dl class="section return"><dt>Returns</dt><dd>list of paired devices as received from the remote status </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/core/<a class="el" href="DeviceManager_8h_source.html">DeviceManager.h</a></li>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/core/DeviceManager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
