<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BeeeOn Gateway: BeeeOn::JournalQueuingStrategy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Gateway
   &#160;<span id="projectnumber">v2018.07.1-rc2</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BeeeOn</b></li><li class="navelem"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html">JournalQueuingStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BeeeOn::JournalQueuingStrategy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> implements persistent temporary storing of <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> into a filesystem structure. It controls contents of a selected directory. The contents consists of buffer files and an index file (journal).  
 <a href="classBeeeOn_1_1JournalQueuingStrategy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="JournalQueuingStrategy_8h_source.html">JournalQueuingStrategy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BeeeOn::JournalQueuingStrategy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBeeeOn_1_1JournalQueuingStrategy.png" usemap="#BeeeOn::JournalQueuingStrategy_map" alt=""/>
  <map id="BeeeOn::JournalQueuingStrategy_map" name="BeeeOn::JournalQueuingStrategy_map">
<area href="classBeeeOn_1_1QueuingStrategy.html" alt="BeeeOn::QueuingStrategy" shape="rect" coords="0,0,274,24"/>
<area href="classBeeeOn_1_1Loggable.html" alt="BeeeOn::Loggable" shape="rect" coords="284,0,558,24"/>
<area href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html" title="RecoverableJournalQueuingStrategy works the same way as the JournalQueuingStrategy but it extends its..." alt="BeeeOn::RecoverableJournalQueuingStrategy" shape="rect" coords="142,112,416,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1Entry.html">Entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1Entry.html" title="An instance of Entry represents a single record in the FileBuffer. Such record contains a single Sens...">Entry</a> represents a single record in the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1FileBuffer.html" title="Representation of a persistent file buffer that contains entries holding the stored SensorData...">FileBuffer</a>. Such record contains a single <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> instance. Moreover, name of the source buffer and offset after the parsed data is provided.  <a href="classBeeeOn_1_1JournalQueuingStrategy_1_1Entry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1FileBuffer.html">FileBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a persistent file buffer that contains entries holding the stored <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a>.  <a href="classBeeeOn_1_1JournalQueuingStrategy_1_1FileBuffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBeeeOn_1_1JournalQueuingStrategy_1_1FileBufferStat.html">FileBufferStat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct with statistics collected during an inspection of a <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1FileBuffer.html" title="Representation of a persistent file buffer that contains entries holding the stored SensorData...">FileBuffer</a> instance.  <a href="structBeeeOn_1_1JournalQueuingStrategy_1_1FileBufferStat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b043519cc56089d5c5587a7ccc9b700"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b043519cc56089d5c5587a7ccc9b700"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a4b043519cc56089d5c5587a7ccc9b700">setRootDir</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a4b043519cc56089d5c5587a7ccc9b700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root directory where to create or use a storage. <br/></td></tr>
<tr class="separator:a4b043519cc56089d5c5587a7ccc9b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170fff4557c0efbf1df0b974311a4af"><td class="memItemLeft" align="right" valign="top">Poco::Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a6170fff4557c0efbf1df0b974311a4af">rootDir</a> () const </td></tr>
<tr class="separator:a6170fff4557c0efbf1df0b974311a4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad02148e1b7b9c971c1753351d34c3e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad02148e1b7b9c971c1753351d34c3e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aad02148e1b7b9c971c1753351d34c3e4">setDisableGC</a> (bool disable)</td></tr>
<tr class="memdesc:aad02148e1b7b9c971c1753351d34c3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable garbage-collection entirely. This is useful for debugging or in case of a serious bug in the GC code. <br/></td></tr>
<tr class="separator:aad02148e1b7b9c971c1753351d34c3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec1b88dab5b316f997b52006ad6886a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ec1b88dab5b316f997b52006ad6886a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a7ec1b88dab5b316f997b52006ad6886a">setNeverDropOldest</a> (bool neverDrop)</td></tr>
<tr class="memdesc:a7ec1b88dab5b316f997b52006ad6886a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable dropping of oldest data. This is useful for debugging or in case of a serious bug in the dropping code. <br/></td></tr>
<tr class="separator:a7ec1b88dab5b316f997b52006ad6886a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678ea887006b9f212d23575dae4e6cee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678ea887006b9f212d23575dae4e6cee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a678ea887006b9f212d23575dae4e6cee">setBytesLimit</a> (int bytes)</td></tr>
<tr class="memdesc:a678ea887006b9f212d23575dae4e6cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set top limit for data consumed by the strategy in the filesystem. This counts all data files (also dangling buffers, locks and index). When setting to a negative value, it is treated as unlimited. <br/></td></tr>
<tr class="separator:a678ea887006b9f212d23575dae4e6cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86859d59fe6bea461434eabf90b23889"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a86859d59fe6bea461434eabf90b23889">overLimit</a> (size_t bytes) const </td></tr>
<tr class="separator:a86859d59fe6bea461434eabf90b23889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a205bd24d1e25df1238222984e22ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a205bd24d1e25df1238222984e22ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aa0a205bd24d1e25df1238222984e22ea">setIgnoreIndexErrors</a> (bool ignore)</td></tr>
<tr class="memdesc:aa0a205bd24d1e25df1238222984e22ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure behaviour of index loading. If the index contains broken entries, we can either fail quickly or ignore such errors and load as much as possible. Ignoring erros can lead to data loss in some cases but it is more probable that we would just peek &amp; pop some already peeked data. The setting is applied only during <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aff94abfe05f6870c7b0f2e1c2ead11ae" title="Setup the storage for the JournalQueuingStrategy. It creates new index or loads the existing one...">JournalQueuingStrategy::setup()</a>. <br/></td></tr>
<tr class="separator:aa0a205bd24d1e25df1238222984e22ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff94abfe05f6870c7b0f2e1c2ead11ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff94abfe05f6870c7b0f2e1c2ead11ae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aff94abfe05f6870c7b0f2e1c2ead11ae">setup</a> ()</td></tr>
<tr class="memdesc:aff94abfe05f6870c7b0f2e1c2ead11ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the storage for the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a>. It creates new index or loads the existing one. All buffers present in the index are checked and registered for future use. <br/></td></tr>
<tr class="separator:aff94abfe05f6870c7b0f2e1c2ead11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e22b72f46626a9abef0980bf8b52e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a4a4e22b72f46626a9abef0980bf8b52e">empty</a> () override</td></tr>
<tr class="memdesc:a4a4e22b72f46626a9abef0980bf8b52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The call might call <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a0b283928c47f32f50267b17fc93d9209" title="The call ensures that there are up to count entries into the m_entryCache. If there is not enough dat...">precacheEntries()</a> to load up to 1 entry.  <a href="#a4a4e22b72f46626a9abef0980bf8b52e">More...</a><br/></td></tr>
<tr class="separator:a4a4e22b72f46626a9abef0980bf8b52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8b64d8ab42742c1ffe0c82f61717b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe8b64d8ab42742c1ffe0c82f61717b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#abe8b64d8ab42742c1ffe0c82f61717b7">push</a> (const std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;data) override</td></tr>
<tr class="memdesc:abe8b64d8ab42742c1ffe0c82f61717b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the given data into a separate buffer and update the index accordingly. In case of serious failure, the method can throw exceptions. <br/></td></tr>
<tr class="separator:abe8b64d8ab42742c1ffe0c82f61717b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d63d53ba2b2b3beda1a3c4e4a690d6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a3d63d53ba2b2b3beda1a3c4e4a690d6d">peek</a> (std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;data, size_t count) override</td></tr>
<tr class="memdesc:a3d63d53ba2b2b3beda1a3c4e4a690d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the given count of data off the registered buffers starting from the oldest one. Calling this method is stable (returns the same results) until the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a307b2cd8561111fb1b6c9df04ca3e183" title="Pop the count amount of data off the registered buffers. It updates index accordingly. ">pop()</a> method is called. Index is not affected by this call.  <a href="#a3d63d53ba2b2b3beda1a3c4e4a690d6d">More...</a><br/></td></tr>
<tr class="separator:a3d63d53ba2b2b3beda1a3c4e4a690d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307b2cd8561111fb1b6c9df04ca3e183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307b2cd8561111fb1b6c9df04ca3e183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a307b2cd8561111fb1b6c9df04ca3e183">pop</a> (size_t count) override</td></tr>
<tr class="memdesc:a307b2cd8561111fb1b6c9df04ca3e183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the count amount of data off the registered buffers. It updates index accordingly. <br/></td></tr>
<tr class="separator:a307b2cd8561111fb1b6c9df04ca3e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a28dcb79a744923432bc1ee3ef70bdce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28dcb79a744923432bc1ee3ef70bdce7"></a>
typedef std::function&lt; void(const <br class="typebreak"/>
std::string &amp;name, size_t <br class="typebreak"/>
offset, Poco::Timestamp <br class="typebreak"/>
&amp;newest)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BrokenHandler</b></td></tr>
<tr class="separator:a28dcb79a744923432bc1ee3ef70bdce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6ef7b5e37452c91732374dc94da7213d"><td class="memItemLeft" align="right" valign="top">Poco::Timestamp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a6ef7b5e37452c91732374dc94da7213d">initIndexAndScan</a> (BrokenHandler broken)</td></tr>
<tr class="memdesc:a6ef7b5e37452c91732374dc94da7213d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs all the necessary steps done when calling <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aff94abfe05f6870c7b0f2e1c2ead11ae" title="Setup the storage for the JournalQueuingStrategy. It creates new index or loads the existing one...">setup()</a>. The given function is called when a broken buffer is detected.  <a href="#a6ef7b5e37452c91732374dc94da7213d">More...</a><br/></td></tr>
<tr class="separator:a6ef7b5e37452c91732374dc94da7213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdabb64278190634b4575550699b665a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdabb64278190634b4575550699b665a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#acdabb64278190634b4575550699b665a">initIndex</a> (const Poco::Path &amp;<a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#ab2a91776d6b05c3359828c714e5db38e">index</a>)</td></tr>
<tr class="memdesc:acdabb64278190634b4575550699b665a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the journaling index either by creating a new empty one or by loading the existing one. <br/></td></tr>
<tr class="separator:acdabb64278190634b4575550699b665a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3642bf5d270ad9b8d4b9fdfe2bc04c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c3642bf5d270ad9b8d4b9fdfe2bc04c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a2c3642bf5d270ad9b8d4b9fdfe2bc04c">prescanBuffers</a> (Poco::Timestamp &amp;newest, BrokenHandler broken)</td></tr>
<tr class="memdesc:a2c3642bf5d270ad9b8d4b9fdfe2bc04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-scan all buffers in the index, check their consistency, collect some information (entries counts, errors, etc.) and update the index after any changes or fixes. <br/></td></tr>
<tr class="separator:a2c3642bf5d270ad9b8d4b9fdfe2bc04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32a6dba8e83e1f17024ad8eaa7a8f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe32a6dba8e83e1f17024ad8eaa7a8f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#afe32a6dba8e83e1f17024ad8eaa7a8f0">reportStats</a> (const Poco::Timestamp &amp;newest) const </td></tr>
<tr class="memdesc:afe32a6dba8e83e1f17024ad8eaa7a8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report statistics about buffers. <br/></td></tr>
<tr class="separator:afe32a6dba8e83e1f17024ad8eaa7a8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c7d08af573429bc7c6362669cf2ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c7d08af573429bc7c6362669cf2ff5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a46c7d08af573429bc7c6362669cf2ff5">inspectAndRegisterBuffer</a> (const std::string &amp;name, size_t offset, Poco::Timestamp &amp;newest)</td></tr>
<tr class="memdesc:a46c7d08af573429bc7c6362669cf2ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect buffer of the given name. <br/></td></tr>
<tr class="separator:a46c7d08af573429bc7c6362669cf2ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a91776d6b05c3359828c714e5db38e"><td class="memItemLeft" align="right" valign="top">Journal::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#ab2a91776d6b05c3359828c714e5db38e">index</a> () const </td></tr>
<tr class="separator:ab2a91776d6b05c3359828c714e5db38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf7be25e8d3716fa9bad1540714422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2caf7be25e8d3716fa9bad1540714422"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a2caf7be25e8d3716fa9bad1540714422">writeData</a> (const std::string &amp;data, bool force=true) const </td></tr>
<tr class="memdesc:a2caf7be25e8d3716fa9bad1540714422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data safely to a file and return its name. <br/></td></tr>
<tr class="separator:a2caf7be25e8d3716fa9bad1540714422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee42bcae059335f838f27b8e6332a3f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee42bcae059335f838f27b8e6332a3f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aee42bcae059335f838f27b8e6332a3f0">whipeFile</a> (Poco::File file, bool usuallyFails=false) const </td></tr>
<tr class="memdesc:aee42bcae059335f838f27b8e6332a3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given file if possible. If usuallyFails is true, than the method does not log errors. <br/></td></tr>
<tr class="separator:aee42bcae059335f838f27b8e6332a3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4e04ba8924fc945610a937a4dc20de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4e04ba8924fc945610a937a4dc20de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a9d4e04ba8924fc945610a937a4dc20de">collectReferenced</a> (std::set&lt; std::string &gt; &amp;referenced) const </td></tr>
<tr class="memdesc:a9d4e04ba8924fc945610a937a4dc20de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all referenced buffers. Such buffers must not be deleted and should not be affected in anyway as they are suspects of <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a3d63d53ba2b2b3beda1a3c4e4a690d6d" title="Peek the given count of data off the registered buffers starting from the oldest one. Calling this method is stable (returns the same results) until the pop() method is called. Index is not affected by this call. ">peek()</a>/pop() API. <br/></td></tr>
<tr class="separator:a9d4e04ba8924fc945610a937a4dc20de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0bcb8f8774c7a1cb7bb06788a97b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62c0bcb8f8774c7a1cb7bb06788a97b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a62c0bcb8f8774c7a1cb7bb06788a97b8">garbageCollect</a> (const size_t bytes)</td></tr>
<tr class="memdesc:a62c0bcb8f8774c7a1cb7bb06788a97b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform garbage collection to ensure that at least the given bytes amount of space is available for writing. <br/></td></tr>
<tr class="separator:a62c0bcb8f8774c7a1cb7bb06788a97b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add97a136cf8938dc20c51daf2e13fdd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add97a136cf8938dc20c51daf2e13fdd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#add97a136cf8938dc20c51daf2e13fdd6">dropOldestBuffers</a> (const size_t bytes)</td></tr>
<tr class="memdesc:add97a136cf8938dc20c51daf2e13fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop oldest valid data to ensure that at least the given bytes amount of space is available for writing. <br/></td></tr>
<tr class="separator:add97a136cf8938dc20c51daf2e13fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584541be030509fcacd219641c44d97d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a584541be030509fcacd219641c44d97d">bytesUsed</a> () const </td></tr>
<tr class="separator:a584541be030509fcacd219641c44d97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d21c18d1377d7daef9320130ddb8a6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a1d21c18d1377d7daef9320130ddb8a6f">bytesUsedAll</a> () const </td></tr>
<tr class="separator:a1d21c18d1377d7daef9320130ddb8a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a25e98f42452dfc2e286813c1ecabc"><td class="memItemLeft" align="right" valign="top">Poco::Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a20a25e98f42452dfc2e286813c1ecabc">pathTo</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a20a25e98f42452dfc2e286813c1ecabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b283928c47f32f50267b17fc93d9209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b283928c47f32f50267b17fc93d9209"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a0b283928c47f32f50267b17fc93d9209">precacheEntries</a> (size_t count)</td></tr>
<tr class="memdesc:a0b283928c47f32f50267b17fc93d9209"><td class="mdescLeft">&#160;</td><td class="mdescRight">The call ensures that there are up to count entries into the m_entryCache. If there is not enough data in the m_entryCache, more data is read from the appropriate buffer. This call helps to ensure that we do not read any data twice. Also, in case a buffer becomes unreadable for some reason, it would no be read again. The index is not affected by this call. <br/></td></tr>
<tr class="separator:a0b283928c47f32f50267b17fc93d9209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb5ddb639427b28a52ea61b2037f0f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb5ddb639427b28a52ea61b2037f0f7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aafb5ddb639427b28a52ea61b2037f0f7">readEntries</a> (std::function&lt; void(const <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1Entry.html">Entry</a> &amp;entry)&gt; proc, size_t count)</td></tr>
<tr class="memdesc:aafb5ddb639427b28a52ea61b2037f0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read up to count entries sequentially from buffers. For each entry, call the given method proc. Buffers' offsets are being updated during this process. The method itself does not modify the index in anyway. <br/></td></tr>
<tr class="separator:aafb5ddb639427b28a52ea61b2037f0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b9055df9470449b7404109dce17bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b4b9055df9470449b7404109dce17bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a2b4b9055df9470449b7404109dce17bf">registerBuffer</a> (const <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1FileBuffer.html">FileBuffer</a> &amp;buffer, const <a class="el" href="structBeeeOn_1_1JournalQueuingStrategy_1_1FileBufferStat.html">FileBufferStat</a> &amp;stat)</td></tr>
<tr class="memdesc:a2b4b9055df9470449b7404109dce17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the given buffer with the strategy. The index is not updated by this call. <br/></td></tr>
<tr class="separator:a2b4b9055df9470449b7404109dce17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89c60789e75cb07103e46d40a3ebb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setupLogger</b> (Poco::Logger *logger=0) const </td></tr>
<tr class="separator:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f8405547e70200fe594a24906d7e7e"></a>
Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>logger</b> () const </td></tr>
<tr class="separator:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28780034cab771631dfb4db98a7954bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba38a43bcc45e65dfb6455ad8ad2e1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a7e9d33e4f3bf626177c34a5c1157453a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a7e9d33e4f3bf626177c34a5c1157453a">tsString</a> (const Poco::Timestamp &amp;t)</td></tr>
<tr class="separator:a7e9d33e4f3bf626177c34a5c1157453a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93889eade4537aea6abb3f383a8463e"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forMethod</b> (const char *name)</td></tr>
<tr class="separator:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a559c00fe671201e7ee5cebf19706491d"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99f58cf545bb5550c42fbb75d4645c4a"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ddc275e696705f0e68a5332d2cd5960"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplItemLeft" align="right" valign="top">static Poco::Logger &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forInstance</b> (const T *i)</td></tr>
<tr class="separator:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c03d407c8269d8fc9f71f0161ae17ae"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>configureSimple</b> (Poco::Logger &amp;logger, const std::string &amp;level)</td></tr>
<tr class="separator:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classBeeeOn_1_1QueuingStrategy"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classBeeeOn_1_1QueuingStrategy')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classBeeeOn_1_1QueuingStrategy.html">BeeeOn::QueuingStrategy</a></td></tr>
<tr class="memitem:abaad188e9c7f4e8566ad933d5322fa66 inherit pub_types_classBeeeOn_1_1QueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaad188e9c7f4e8566ad933d5322fa66"></a>
typedef Poco::SharedPtr<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1QueuingStrategy.html">QueuingStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:abaad188e9c7f4e8566ad933d5322fa66 inherit pub_types_classBeeeOn_1_1QueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> implements persistent temporary storing of <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> into a filesystem structure. It controls contents of a selected directory. The contents consists of buffer files and an index file (journal). </p>
<p>The <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> maintains 3 kinds of files:</p>
<ul>
<li>buffers - files named after their SHA-1 checksum (Git-like) containing serialized <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> instances in a line-oriented way with CRC32 protection per-record</li>
<li>index - index of buffer files and byte offsets into them implemented as a journal (mostly append only file)</li>
<li>locks - when writing a file at once to disk (mostly buffers), a temporary lock files are created</li>
</ul>
<p>Writing data into the storage are controlled by the bytesLimit. If the limit is reached by all persisted files (both active or dangling), the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> tries to garbage collect unused (dangling) files and if it does not succeed then it drops also valid data that were not peeked yet. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a584541be030509fcacd219641c44d97d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t JournalQueuingStrategy::bytesUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>amount of bytes occupied by active buffers and index. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d21c18d1377d7daef9320130ddb8a6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t JournalQueuingStrategy::bytesUsedAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>amount of bytes occupied by all files related to the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> (including lock files and dangling buffers). </dd></dl>

</div>
</div>
<a class="anchor" id="a4a4e22b72f46626a9abef0980bf8b52e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JournalQueuingStrategy::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The call might call <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a0b283928c47f32f50267b17fc93d9209" title="The call ensures that there are up to count entries into the m_entryCache. If there is not enough dat...">precacheEntries()</a> to load up to 1 entry. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is no buffer containing peekable data. </dd></dl>

<p>Implements <a class="el" href="classBeeeOn_1_1QueuingStrategy.html#a6934bc6c9f07ea9f9395cabf050c10c5">BeeeOn::QueuingStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="ab2a91776d6b05c3359828c714e5db38e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Journal::Ptr JournalQueuingStrategy::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the underlying index. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ef7b5e37452c91732374dc94da7213d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Timestamp JournalQueuingStrategy::initIndexAndScan </td>
          <td>(</td>
          <td class="paramtype">BrokenHandler&#160;</td>
          <td class="paramname"><em>broken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs all the necessary steps done when calling <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aff94abfe05f6870c7b0f2e1c2ead11ae" title="Setup the storage for the JournalQueuingStrategy. It creates new index or loads the existing one...">setup()</a>. The given function is called when a broken buffer is detected. </p>
<dl class="section return"><dt>Returns</dt><dd>timestamp of the newest detected buffered data. </dd></dl>

</div>
</div>
<a class="anchor" id="a86859d59fe6bea461434eabf90b23889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JournalQueuingStrategy::overLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if an over limit is detected for the given amount of consumed space in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a20a25e98f42452dfc2e286813c1ecabc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Path JournalQueuingStrategy::pathTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>path to the given name relative to the rootDir. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d63d53ba2b2b3beda1a3c4e4a690d6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t JournalQueuingStrategy::peek </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek the given count of data off the registered buffers starting from the oldest one. Calling this method is stable (returns the same results) until the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a307b2cd8561111fb1b6c9df04ca3e183" title="Pop the count amount of data off the registered buffers. It updates index accordingly. ">pop()</a> method is called. Index is not affected by this call. </p>
<p>It is not expected to peek large amounts of data because the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a3d63d53ba2b2b3beda1a3c4e4a690d6d" title="Peek the given count of data off the registered buffers starting from the oldest one. Calling this method is stable (returns the same results) until the pop() method is called. Index is not affected by this call. ">peek()</a> call caches all such data in RAM. </p>

<p>Implements <a class="el" href="classBeeeOn_1_1QueuingStrategy.html#a5e85be6c4c9d22dbb6fc42783078cf49">BeeeOn::QueuingStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a6170fff4557c0efbf1df0b974311a4af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Path JournalQueuingStrategy::rootDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>rootDir where the repository is located. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e9d33e4f3bf626177c34a5c1157453a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string JournalQueuingStrategy::tsString </td>
          <td>(</td>
          <td class="paramtype">const Poco::Timestamp &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>string representation of the given timestamp. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/exporters/<a class="el" href="JournalQueuingStrategy_8h_source.html">JournalQueuingStrategy.h</a></li>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/exporters/JournalQueuingStrategy.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
