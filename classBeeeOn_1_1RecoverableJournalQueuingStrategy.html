<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BeeeOn Gateway: BeeeOn::RecoverableJournalQueuingStrategy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Gateway
   &#160;<span id="projectnumber">v2018.07.1-rc2-18-ge467341</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BeeeOn</b></li><li class="navelem"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html">RecoverableJournalQueuingStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BeeeOn::RecoverableJournalQueuingStrategy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html" title="RecoverableJournalQueuingStrategy works the same way as the JournalQueuingStrategy but it extends its...">RecoverableJournalQueuingStrategy</a> works the same way as the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> but it extends its behaviour with recovering features. The <a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html" title="RecoverableJournalQueuingStrategy works the same way as the JournalQueuingStrategy but it extends its...">RecoverableJournalQueuingStrategy</a> can recover partially broken and non-commited buffers.  
 <a href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RecoverableJournalQueuingStrategy_8h_source.html">RecoverableJournalQueuingStrategy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BeeeOn::RecoverableJournalQueuingStrategy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBeeeOn_1_1RecoverableJournalQueuingStrategy.png" usemap="#BeeeOn::RecoverableJournalQueuingStrategy_map" alt=""/>
  <map id="BeeeOn::RecoverableJournalQueuingStrategy_map" name="BeeeOn::RecoverableJournalQueuingStrategy_map">
<area href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct..." alt="BeeeOn::JournalQueuingStrategy" shape="rect" coords="142,56,416,80"/>
<area href="classBeeeOn_1_1QueuingStrategy.html" alt="BeeeOn::QueuingStrategy" shape="rect" coords="0,0,274,24"/>
<area href="classBeeeOn_1_1Loggable.html" alt="BeeeOn::Loggable" shape="rect" coords="284,0,558,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab96814d6ad071254692a554dda3cbbe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab96814d6ad071254692a554dda3cbbe2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#ab96814d6ad071254692a554dda3cbbe2">setDisableTmpDataRecovery</a> (bool disable)</td></tr>
<tr class="memdesc:ab96814d6ad071254692a554dda3cbbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable running recovery of the data.tmp file. <br/></td></tr>
<tr class="separator:ab96814d6ad071254692a554dda3cbbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3060ce0e308b95882530ea6ec0664f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e3060ce0e308b95882530ea6ec0664f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#a7e3060ce0e308b95882530ea6ec0664f">setDisableBrokenRecovery</a> (bool disable)</td></tr>
<tr class="memdesc:a7e3060ce0e308b95882530ea6ec0664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable running recovery of broken buffers referenced from index. Such buffers are ignored (and potentially garbage collected). <br/></td></tr>
<tr class="separator:a7e3060ce0e308b95882530ea6ec0664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51a0a26ff0f5b0b4be5935939e0daa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac51a0a26ff0f5b0b4be5935939e0daa6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#ac51a0a26ff0f5b0b4be5935939e0daa6">setDisableLostRecovery</a> (bool disable)</td></tr>
<tr class="memdesc:ac51a0a26ff0f5b0b4be5935939e0daa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable running recovery of lost buffers - ie. buffers that were not appended to index but contain recent data. <br/></td></tr>
<tr class="separator:ac51a0a26ff0f5b0b4be5935939e0daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aeb2650c6df65f104c00c185da55b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2aeb2650c6df65f104c00c185da55b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#ac2aeb2650c6df65f104c00c185da55b1">setup</a> () override</td></tr>
<tr class="memdesc:ac2aeb2650c6df65f104c00c185da55b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the storage for the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a>. It creates new index or loads the existing one. All buffers present in the index are checked and registered for future use. <br/></td></tr>
<tr class="separator:ac2aeb2650c6df65f104c00c185da55b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classBeeeOn_1_1JournalQueuingStrategy')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html">BeeeOn::JournalQueuingStrategy</a></td></tr>
<tr class="memitem:a4b043519cc56089d5c5587a7ccc9b700 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b043519cc56089d5c5587a7ccc9b700"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a4b043519cc56089d5c5587a7ccc9b700">setRootDir</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a4b043519cc56089d5c5587a7ccc9b700 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root directory where to create or use a storage. <br/></td></tr>
<tr class="separator:a4b043519cc56089d5c5587a7ccc9b700 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170fff4557c0efbf1df0b974311a4af inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">Poco::Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a6170fff4557c0efbf1df0b974311a4af">rootDir</a> () const </td></tr>
<tr class="separator:a6170fff4557c0efbf1df0b974311a4af inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad02148e1b7b9c971c1753351d34c3e4 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad02148e1b7b9c971c1753351d34c3e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aad02148e1b7b9c971c1753351d34c3e4">setDisableGC</a> (bool disable)</td></tr>
<tr class="memdesc:aad02148e1b7b9c971c1753351d34c3e4 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable garbage-collection entirely. This is useful for debugging or in case of a serious bug in the GC code. <br/></td></tr>
<tr class="separator:aad02148e1b7b9c971c1753351d34c3e4 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec1b88dab5b316f997b52006ad6886a inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ec1b88dab5b316f997b52006ad6886a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a7ec1b88dab5b316f997b52006ad6886a">setNeverDropOldest</a> (bool neverDrop)</td></tr>
<tr class="memdesc:a7ec1b88dab5b316f997b52006ad6886a inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable dropping of oldest data. This is useful for debugging or in case of a serious bug in the dropping code. <br/></td></tr>
<tr class="separator:a7ec1b88dab5b316f997b52006ad6886a inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678ea887006b9f212d23575dae4e6cee inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678ea887006b9f212d23575dae4e6cee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a678ea887006b9f212d23575dae4e6cee">setBytesLimit</a> (int bytes)</td></tr>
<tr class="memdesc:a678ea887006b9f212d23575dae4e6cee inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set top limit for data consumed by the strategy in the filesystem. This counts all data files (also dangling buffers, locks and index). When setting to a negative value, it is treated as unlimited. <br/></td></tr>
<tr class="separator:a678ea887006b9f212d23575dae4e6cee inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86859d59fe6bea461434eabf90b23889 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a86859d59fe6bea461434eabf90b23889">overLimit</a> (size_t bytes) const </td></tr>
<tr class="separator:a86859d59fe6bea461434eabf90b23889 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a205bd24d1e25df1238222984e22ea inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a205bd24d1e25df1238222984e22ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aa0a205bd24d1e25df1238222984e22ea">setIgnoreIndexErrors</a> (bool ignore)</td></tr>
<tr class="memdesc:aa0a205bd24d1e25df1238222984e22ea inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure behaviour of index loading. If the index contains broken entries, we can either fail quickly or ignore such errors and load as much as possible. Ignoring erros can lead to data loss in some cases but it is more probable that we would just peek &amp; pop some already peeked data. The setting is applied only during <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aff94abfe05f6870c7b0f2e1c2ead11ae" title="Setup the storage for the JournalQueuingStrategy. It creates new index or loads the existing one...">JournalQueuingStrategy::setup()</a>. <br/></td></tr>
<tr class="separator:aa0a205bd24d1e25df1238222984e22ea inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e22b72f46626a9abef0980bf8b52e inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a4a4e22b72f46626a9abef0980bf8b52e">empty</a> () override</td></tr>
<tr class="memdesc:a4a4e22b72f46626a9abef0980bf8b52e inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">The call might call <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a0b283928c47f32f50267b17fc93d9209" title="The call ensures that there are up to count entries into the m_entryCache. If there is not enough dat...">precacheEntries()</a> to load up to 1 entry.  <a href="#a4a4e22b72f46626a9abef0980bf8b52e">More...</a><br/></td></tr>
<tr class="separator:a4a4e22b72f46626a9abef0980bf8b52e inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8b64d8ab42742c1ffe0c82f61717b7 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe8b64d8ab42742c1ffe0c82f61717b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#abe8b64d8ab42742c1ffe0c82f61717b7">push</a> (const std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;data) override</td></tr>
<tr class="memdesc:abe8b64d8ab42742c1ffe0c82f61717b7 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the given data into a separate buffer and update the index accordingly. In case of serious failure, the method can throw exceptions. <br/></td></tr>
<tr class="separator:abe8b64d8ab42742c1ffe0c82f61717b7 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d63d53ba2b2b3beda1a3c4e4a690d6d inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a3d63d53ba2b2b3beda1a3c4e4a690d6d">peek</a> (std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;data, size_t count) override</td></tr>
<tr class="memdesc:a3d63d53ba2b2b3beda1a3c4e4a690d6d inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the given count of data off the registered buffers starting from the oldest one. Calling this method is stable (returns the same results) until the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a307b2cd8561111fb1b6c9df04ca3e183" title="Pop the count amount of data off the registered buffers. It updates index accordingly. ">pop()</a> method is called. Index is not affected by this call.  <a href="#a3d63d53ba2b2b3beda1a3c4e4a690d6d">More...</a><br/></td></tr>
<tr class="separator:a3d63d53ba2b2b3beda1a3c4e4a690d6d inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307b2cd8561111fb1b6c9df04ca3e183 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307b2cd8561111fb1b6c9df04ca3e183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a307b2cd8561111fb1b6c9df04ca3e183">pop</a> (size_t count) override</td></tr>
<tr class="memdesc:a307b2cd8561111fb1b6c9df04ca3e183 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the count amount of data off the registered buffers. It updates index accordingly. <br/></td></tr>
<tr class="separator:a307b2cd8561111fb1b6c9df04ca3e183 inherit pub_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a94cdb1a8d3d783b292c422f907b475fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94cdb1a8d3d783b292c422f907b475fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#a94cdb1a8d3d783b292c422f907b475fe">collectRecoverable</a> (std::list&lt; Poco::File &gt; &amp;files) const </td></tr>
<tr class="memdesc:a94cdb1a8d3d783b292c422f907b475fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect files looking like buffers that are not referenced and thus are potentially recoverable for some reason. <br/></td></tr>
<tr class="separator:a94cdb1a8d3d783b292c422f907b475fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6357f90383841a3a9a44e75b584339"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#a6e6357f90383841a3a9a44e75b584339">recoverEntries</a> (Poco::File file, std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;data) const </td></tr>
<tr class="memdesc:a6e6357f90383841a3a9a44e75b584339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the given file and parse its contents like it is a buffer. In this way, we read as much of entries as possible while skipping errors.  <a href="#a6e6357f90383841a3a9a44e75b584339">More...</a><br/></td></tr>
<tr class="separator:a6e6357f90383841a3a9a44e75b584339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ed7b9d4536a0efff1e906767ea519d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ed7b9d4536a0efff1e906767ea519d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#a80ed7b9d4536a0efff1e906767ea519d">recoverBrokenBuffer</a> (Poco::File file) const </td></tr>
<tr class="memdesc:a80ed7b9d4536a0efff1e906767ea519d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover contents of the given file into a new file that has a valid digest. Empty files are deleted. If the given file represents a valid buffer with a valid digest, it is left untouched. <br/></td></tr>
<tr class="separator:a80ed7b9d4536a0efff1e906767ea519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd140fd8b23fbc1ac5ed2f32e9af17d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacd140fd8b23fbc1ac5ed2f32e9af17d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#aacd140fd8b23fbc1ac5ed2f32e9af17d">recoverBuffer</a> (Poco::File tmpFile) const </td></tr>
<tr class="memdesc:aacd140fd8b23fbc1ac5ed2f32e9af17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the given file as it should be a buffer. This method is useful to recover file that are not named accordingly - ie. we are not sure about their validity. It calls <a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#a80ed7b9d4536a0efff1e906767ea519d" title="Recover contents of the given file into a new file that has a valid digest. Empty files are deleted...">recoverBrokenBuffer()</a>. <br/></td></tr>
<tr class="separator:aacd140fd8b23fbc1ac5ed2f32e9af17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf93a4a42482b5a3898f0abfd0cf835"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaf93a4a42482b5a3898f0abfd0cf835"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#adaf93a4a42482b5a3898f0abfd0cf835">recoverTmpData</a> (Poco::Timestamp &amp;newest)</td></tr>
<tr class="memdesc:adaf93a4a42482b5a3898f0abfd0cf835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the data.tmp file if present and append it to the index. <br/></td></tr>
<tr class="separator:adaf93a4a42482b5a3898f0abfd0cf835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98a267a9cd85a97326ad715fab75756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#ac98a267a9cd85a97326ad715fab75756">recoverBroken</a> (const std::string &amp;broken, Poco::Timestamp &amp;newest)</td></tr>
<tr class="separator:ac98a267a9cd85a97326ad715fab75756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a813c9a571d10fbe4f0ca8136f5669"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a813c9a571d10fbe4f0ca8136f5669"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html#a66a813c9a571d10fbe4f0ca8136f5669">recoverLost</a> (std::list&lt; Poco::File &gt; &amp;recoverable, const Poco::Timestamp &amp;indexModified, const Poco::Timestamp &amp;newest)</td></tr>
<tr class="memdesc:a66a813c9a571d10fbe4f0ca8136f5669"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a list of potentially recoverable buffers, recover those that has newer timestamps than the newest timestamp registered in the index. Also, timestamp of the last index file modification is used to speed up this process. <br/></td></tr>
<tr class="separator:a66a813c9a571d10fbe4f0ca8136f5669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classBeeeOn_1_1JournalQueuingStrategy')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html">BeeeOn::JournalQueuingStrategy</a></td></tr>
<tr class="memitem:a6ef7b5e37452c91732374dc94da7213d inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">Poco::Timestamp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a6ef7b5e37452c91732374dc94da7213d">initIndexAndScan</a> (BrokenHandler broken)</td></tr>
<tr class="memdesc:a6ef7b5e37452c91732374dc94da7213d inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs all the necessary steps done when calling <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aff94abfe05f6870c7b0f2e1c2ead11ae" title="Setup the storage for the JournalQueuingStrategy. It creates new index or loads the existing one...">setup()</a>. The given function is called when a broken buffer is detected.  <a href="#a6ef7b5e37452c91732374dc94da7213d">More...</a><br/></td></tr>
<tr class="separator:a6ef7b5e37452c91732374dc94da7213d inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdabb64278190634b4575550699b665a inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdabb64278190634b4575550699b665a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#acdabb64278190634b4575550699b665a">initIndex</a> (const Poco::Path &amp;<a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#ab2a91776d6b05c3359828c714e5db38e">index</a>)</td></tr>
<tr class="memdesc:acdabb64278190634b4575550699b665a inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the journaling index either by creating a new empty one or by loading the existing one. <br/></td></tr>
<tr class="separator:acdabb64278190634b4575550699b665a inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3642bf5d270ad9b8d4b9fdfe2bc04c inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c3642bf5d270ad9b8d4b9fdfe2bc04c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a2c3642bf5d270ad9b8d4b9fdfe2bc04c">prescanBuffers</a> (Poco::Timestamp &amp;newest, BrokenHandler broken)</td></tr>
<tr class="memdesc:a2c3642bf5d270ad9b8d4b9fdfe2bc04c inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-scan all buffers in the index, check their consistency, collect some information (entries counts, errors, etc.) and update the index after any changes or fixes. <br/></td></tr>
<tr class="separator:a2c3642bf5d270ad9b8d4b9fdfe2bc04c inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32a6dba8e83e1f17024ad8eaa7a8f0 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe32a6dba8e83e1f17024ad8eaa7a8f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#afe32a6dba8e83e1f17024ad8eaa7a8f0">reportStats</a> (const Poco::Timestamp &amp;newest) const </td></tr>
<tr class="memdesc:afe32a6dba8e83e1f17024ad8eaa7a8f0 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report statistics about buffers. <br/></td></tr>
<tr class="separator:afe32a6dba8e83e1f17024ad8eaa7a8f0 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c7d08af573429bc7c6362669cf2ff5 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c7d08af573429bc7c6362669cf2ff5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a46c7d08af573429bc7c6362669cf2ff5">inspectAndRegisterBuffer</a> (const std::string &amp;name, size_t offset, Poco::Timestamp &amp;newest)</td></tr>
<tr class="memdesc:a46c7d08af573429bc7c6362669cf2ff5 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect buffer of the given name. <br/></td></tr>
<tr class="separator:a46c7d08af573429bc7c6362669cf2ff5 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a91776d6b05c3359828c714e5db38e inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">Journal::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#ab2a91776d6b05c3359828c714e5db38e">index</a> () const </td></tr>
<tr class="separator:ab2a91776d6b05c3359828c714e5db38e inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf7be25e8d3716fa9bad1540714422 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2caf7be25e8d3716fa9bad1540714422"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a2caf7be25e8d3716fa9bad1540714422">writeData</a> (const std::string &amp;data, bool force=true) const </td></tr>
<tr class="memdesc:a2caf7be25e8d3716fa9bad1540714422 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data safely to a file and return its name. <br/></td></tr>
<tr class="separator:a2caf7be25e8d3716fa9bad1540714422 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee42bcae059335f838f27b8e6332a3f0 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee42bcae059335f838f27b8e6332a3f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aee42bcae059335f838f27b8e6332a3f0">whipeFile</a> (Poco::File file, bool usuallyFails=false) const </td></tr>
<tr class="memdesc:aee42bcae059335f838f27b8e6332a3f0 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given file if possible. If usuallyFails is true, than the method does not log errors. <br/></td></tr>
<tr class="separator:aee42bcae059335f838f27b8e6332a3f0 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4e04ba8924fc945610a937a4dc20de inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4e04ba8924fc945610a937a4dc20de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a9d4e04ba8924fc945610a937a4dc20de">collectReferenced</a> (std::set&lt; std::string &gt; &amp;referenced) const </td></tr>
<tr class="memdesc:a9d4e04ba8924fc945610a937a4dc20de inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all referenced buffers. Such buffers must not be deleted and should not be affected in anyway as they are suspects of <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a3d63d53ba2b2b3beda1a3c4e4a690d6d" title="Peek the given count of data off the registered buffers starting from the oldest one. Calling this method is stable (returns the same results) until the pop() method is called. Index is not affected by this call. ">peek()</a>/pop() API. <br/></td></tr>
<tr class="separator:a9d4e04ba8924fc945610a937a4dc20de inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0bcb8f8774c7a1cb7bb06788a97b8 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62c0bcb8f8774c7a1cb7bb06788a97b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a62c0bcb8f8774c7a1cb7bb06788a97b8">garbageCollect</a> (const size_t bytes)</td></tr>
<tr class="memdesc:a62c0bcb8f8774c7a1cb7bb06788a97b8 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform garbage collection to ensure that at least the given bytes amount of space is available for writing. <br/></td></tr>
<tr class="separator:a62c0bcb8f8774c7a1cb7bb06788a97b8 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add97a136cf8938dc20c51daf2e13fdd6 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add97a136cf8938dc20c51daf2e13fdd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#add97a136cf8938dc20c51daf2e13fdd6">dropOldestBuffers</a> (const size_t bytes)</td></tr>
<tr class="memdesc:add97a136cf8938dc20c51daf2e13fdd6 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop oldest valid data to ensure that at least the given bytes amount of space is available for writing. <br/></td></tr>
<tr class="separator:add97a136cf8938dc20c51daf2e13fdd6 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584541be030509fcacd219641c44d97d inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a584541be030509fcacd219641c44d97d">bytesUsed</a> () const </td></tr>
<tr class="separator:a584541be030509fcacd219641c44d97d inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d21c18d1377d7daef9320130ddb8a6f inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a1d21c18d1377d7daef9320130ddb8a6f">bytesUsedAll</a> () const </td></tr>
<tr class="separator:a1d21c18d1377d7daef9320130ddb8a6f inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a25e98f42452dfc2e286813c1ecabc inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">Poco::Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a20a25e98f42452dfc2e286813c1ecabc">pathTo</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a20a25e98f42452dfc2e286813c1ecabc inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b283928c47f32f50267b17fc93d9209 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b283928c47f32f50267b17fc93d9209"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a0b283928c47f32f50267b17fc93d9209">precacheEntries</a> (size_t count)</td></tr>
<tr class="memdesc:a0b283928c47f32f50267b17fc93d9209 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">The call ensures that there are up to count entries into the m_entryCache. If there is not enough data in the m_entryCache, more data is read from the appropriate buffer. This call helps to ensure that we do not read any data twice. Also, in case a buffer becomes unreadable for some reason, it would no be read again. The index is not affected by this call. <br/></td></tr>
<tr class="separator:a0b283928c47f32f50267b17fc93d9209 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb5ddb639427b28a52ea61b2037f0f7 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb5ddb639427b28a52ea61b2037f0f7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#aafb5ddb639427b28a52ea61b2037f0f7">readEntries</a> (std::function&lt; void(const <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1Entry.html">Entry</a> &amp;entry)&gt; proc, size_t count)</td></tr>
<tr class="memdesc:aafb5ddb639427b28a52ea61b2037f0f7 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read up to count entries sequentially from buffers. For each entry, call the given method proc. Buffers' offsets are being updated during this process. The method itself does not modify the index in anyway. <br/></td></tr>
<tr class="separator:aafb5ddb639427b28a52ea61b2037f0f7 inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b9055df9470449b7404109dce17bf inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b4b9055df9470449b7404109dce17bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a2b4b9055df9470449b7404109dce17bf">registerBuffer</a> (const <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy_1_1FileBuffer.html">FileBuffer</a> &amp;buffer, const <a class="el" href="structBeeeOn_1_1JournalQueuingStrategy_1_1FileBufferStat.html">FileBufferStat</a> &amp;stat)</td></tr>
<tr class="memdesc:a2b4b9055df9470449b7404109dce17bf inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the given buffer with the strategy. The index is not updated by this call. <br/></td></tr>
<tr class="separator:a2b4b9055df9470449b7404109dce17bf inherit pro_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89c60789e75cb07103e46d40a3ebb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setupLogger</b> (Poco::Logger *logger=0) const </td></tr>
<tr class="separator:af89c60789e75cb07103e46d40a3ebb32 inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f8405547e70200fe594a24906d7e7e"></a>
Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>logger</b> () const </td></tr>
<tr class="separator:a46f8405547e70200fe594a24906d7e7e inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28780034cab771631dfb4db98a7954bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a28780034cab771631dfb4db98a7954bb inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba38a43bcc45e65dfb6455ad8ad2e1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Loggable</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:aeba38a43bcc45e65dfb6455ad8ad2e1d inherit pro_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classBeeeOn_1_1QueuingStrategy"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classBeeeOn_1_1QueuingStrategy')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classBeeeOn_1_1QueuingStrategy.html">BeeeOn::QueuingStrategy</a></td></tr>
<tr class="memitem:abaad188e9c7f4e8566ad933d5322fa66 inherit pub_types_classBeeeOn_1_1QueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaad188e9c7f4e8566ad933d5322fa66"></a>
typedef Poco::SharedPtr<br class="typebreak"/>
&lt; <a class="el" href="classBeeeOn_1_1QueuingStrategy.html">QueuingStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:abaad188e9c7f4e8566ad933d5322fa66 inherit pub_types_classBeeeOn_1_1QueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classBeeeOn_1_1JournalQueuingStrategy"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classBeeeOn_1_1JournalQueuingStrategy')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html">BeeeOn::JournalQueuingStrategy</a></td></tr>
<tr class="memitem:a28dcb79a744923432bc1ee3ef70bdce7 inherit pro_types_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28dcb79a744923432bc1ee3ef70bdce7"></a>
typedef std::function&lt; void(const <br class="typebreak"/>
std::string &amp;name, size_t <br class="typebreak"/>
offset, Poco::Timestamp <br class="typebreak"/>
&amp;newest)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BrokenHandler</b></td></tr>
<tr class="separator:a28dcb79a744923432bc1ee3ef70bdce7 inherit pro_types_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classBeeeOn_1_1JournalQueuingStrategy"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classBeeeOn_1_1JournalQueuingStrategy')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html">BeeeOn::JournalQueuingStrategy</a></td></tr>
<tr class="memitem:a7e9d33e4f3bf626177c34a5c1157453a inherit pro_static_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html#a7e9d33e4f3bf626177c34a5c1157453a">tsString</a> (const Poco::Timestamp &amp;t)</td></tr>
<tr class="separator:a7e9d33e4f3bf626177c34a5c1157453a inherit pro_static_methods_classBeeeOn_1_1JournalQueuingStrategy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classBeeeOn_1_1Loggable"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classBeeeOn_1_1Loggable')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classBeeeOn_1_1Loggable.html">BeeeOn::Loggable</a></td></tr>
<tr class="memitem:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93889eade4537aea6abb3f383a8463e"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forMethod</b> (const char *name)</td></tr>
<tr class="separator:ae93889eade4537aea6abb3f383a8463e inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a559c00fe671201e7ee5cebf19706491d"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const <a class="el" href="classBeeeOn_1_1ClassInfo.html">ClassInfo</a> &amp;info)</td></tr>
<tr class="separator:a559c00fe671201e7ee5cebf19706491d inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99f58cf545bb5550c42fbb75d4645c4a"></a>
static Poco::Logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>forClass</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:a99f58cf545bb5550c42fbb75d4645c4a inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ddc275e696705f0e68a5332d2cd5960"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memTemplItemLeft" align="right" valign="top">static Poco::Logger &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forInstance</b> (const T *i)</td></tr>
<tr class="separator:a9ddc275e696705f0e68a5332d2cd5960 inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c03d407c8269d8fc9f71f0161ae17ae"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>configureSimple</b> (Poco::Logger &amp;logger, const std::string &amp;level)</td></tr>
<tr class="separator:a5c03d407c8269d8fc9f71f0161ae17ae inherit pro_static_methods_classBeeeOn_1_1Loggable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html" title="RecoverableJournalQueuingStrategy works the same way as the JournalQueuingStrategy but it extends its...">RecoverableJournalQueuingStrategy</a> works the same way as the <a class="el" href="classBeeeOn_1_1JournalQueuingStrategy.html" title="JournalQueuingStrategy implements persistent temporary storing of SensorData into a filesystem struct...">JournalQueuingStrategy</a> but it extends its behaviour with recovering features. The <a class="el" href="classBeeeOn_1_1RecoverableJournalQueuingStrategy.html" title="RecoverableJournalQueuingStrategy works the same way as the JournalQueuingStrategy but it extends its...">RecoverableJournalQueuingStrategy</a> can recover partially broken and non-commited buffers. </p>
<p>A buffer is recovered when:</p>
<ul>
<li>it was not commited, i.e. the data.tmp file exists, and it is non-empty</li>
<li>a buffer is referenced from index and has an invalid digest</li>
<li>an existing buffer contains timestamps newer than the newest timestamp in buffers referenced from index</li>
</ul>
<p>In this way, we should cover the following situations:</p>
<ul>
<li>power supply failure while writing a buffer: non-committed buffer, committed buffer not recorded in index</li>
<li>non-volatile media failure (written data becomes invalid)</li>
</ul>
<p>The recovery process DOES NOT work in-situ. Buffers being recovered are first loaded into memory and such buffers are not deleted unless written back successfully. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac98a267a9cd85a97326ad715fab75756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RecoverableJournalQueuingStrategy::recoverBroken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>broken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Poco::Timestamp &amp;&#160;</td>
          <td class="paramname"><em>newest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recover a broken buffer and register it. We update the newest timestamp accordingly as the recovered buffer is valid and we have to count on it. </p>

</div>
</div>
<a class="anchor" id="a6e6357f90383841a3a9a44e75b584339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RecoverableJournalQueuingStrategy::recoverEntries </td>
          <td>(</td>
          <td class="paramtype">Poco::File&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBeeeOn_1_1SensorData.html">SensorData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the given file and parse its contents like it is a buffer. In this way, we read as much of entries as possible while skipping errors. </p>
<dl class="section return"><dt>Returns</dt><dd>number of errors occured while parsing </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/exporters/<a class="el" href="RecoverableJournalQueuingStrategy_8h_source.html">RecoverableJournalQueuingStrategy.h</a></li>
<li>/var/lib/jenkins/workspace/beeeon-gateway-master/src/exporters/RecoverableJournalQueuingStrategy.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
